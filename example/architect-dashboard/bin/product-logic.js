/**
 * ðŸ›‘ DO NOT EDIT THIS FILE DIRECTLY
 * ----------------------------------
 * This file was generated by ISL Compiler.
 * Source: product-logic.isl.md
 * Edit the ISL file instead.
 */

import { Product } from "./domain"; // Assuming Product is an exported factory function from ./domain.js

// In-memory store to simulate persistent storage for products
let productStore = [];
let nextProductId = 1; // Simple counter for generating unique product IDs

/**
 * Validates if a given price is a positive number.
 * @param {number} price
 * @returns {boolean}
 */
const isValidPrice = (price) => typeof price === 'number' && price > 0;

/**
 * Validates if a given stock is a non-negative integer.
 * @param {number} stock
 * @returns {boolean}
 */
const isValidStock = (stock) => typeof stock === 'number' && stock >= 0 && Number.isInteger(stock);

/**
 * Checks if a product name is unique across all active products, optionally excluding a specific product ID.
 * @param {string} name
 * @param {string | null} excludeId - ID of the product to exclude from the uniqueness check (for updates).
 * @returns {boolean}
 */
const isProductNameUnique = (name, excludeId = null) => {
  return !productStore.some(p => p.name === name && p.id !== excludeId);
};

/**
 * Retrieves a list of all products available in the system.
 * @returns {Array<ReturnType<typeof Product>>} A list of Product objects.
 */
export function fetchAllProducts() {
  // 1. The system requests all product records.
  // (Simulated by accessing the in-memory productStore)
  // 2. The system compiles the retrieved records into a list of Product objects.
  return productStore.map(p => Product(p));
}

/**
 * Retrieves a single product by its unique identifier.
 * @param {string} productId - The unique identifier of the product.
 * @returns {ReturnType<typeof Product> | null} The Product object if found, otherwise null.
 */
export function fetchProductById(productId) {
  // 1. The system searches for a product record matching the provided productId.
  const foundProductData = productStore.find(p => p.id === productId);

  // 2. If a matching record is found, the system constructs a Product object.
  if (foundProductData) {
    return Product(foundProductData);
  }

  // 3. If no matching record is found, the system indicates absence.
  return null;
}

/**
 * Creates a new product record in the system.
 * @param {{ name: string, description: string, price: number, stock: number, category: string, imageUrl: string }} productDetails - Details for the new product.
 * @returns {ReturnType<typeof Product>} The newly created product, including its generated id.
 * @throws {Error} If validation fails (e.g., name not unique, invalid price/stock).
 */
export function addProduct(productDetails) {
  // 1. The system validates the productDetails against business rules.
  const { name, description, price, stock, category, imageUrl } = productDetails;

  if (!name || typeof name !== 'string' || name.trim() === '') {
    throw new Error("Product name is required.");
  }
  if (!isProductNameUnique(name.trim())) {
    throw new Error(`Product with name '${name.trim()}' already exists.`);
  }
  if (!isValidPrice(price)) {
    throw new Error("Product price must be a positive number.");
  }
  if (!isValidStock(stock)) {
    throw new Error("Product stock must be a non-negative integer.");
  }
  if (!description || typeof description !== 'string' || description.trim() === '') {
    throw new Error("Product description is required.");
  }
  if (!category || typeof category !== 'string' || category.trim() === '') {
    throw new Error("Product category is required.");
  }
  if (!imageUrl || typeof imageUrl !== 'string' || imageUrl.trim() === '') {
    throw new Error("Product image URL is required.");
  }

  // 2. If validation passes, the system generates a unique ProductId.
  const newId = `prod-${nextProductId++}`;

  // 3. The system persists a new product record using the provided details and the generated ProductId.
  const newProductData = {
    id: newId,
    name: name.trim(),
    description: description.trim(),
    price: price,
    stock: stock,
    category: category.trim(),
    imageUrl: imageUrl.trim(),
  };
  productStore.push(newProductData);

  // 4. The system returns the complete Product object.
  return Product(newProductData);
}

/**
 * Modifies an existing product's details.
 * @param {string} productId - The unique identifier of the product to update.
 * @param {{ name?: string, description?: string, price?: number, stock?: number, category?: string, imageUrl?: string }} updateDetails - Partial details to update.
 * @returns {ReturnType<typeof Product>} The updated product object.
 * @throws {Error} If the product is not found or validation fails.
 */
export function updateProduct(productId, updateDetails) {
  // 1. The system locates the existing product record using productId.
  const productIndex = productStore.findIndex(p => p.id === productId);

  if (productIndex === -1) {
    throw new Error(`Product with ID '${productId}' not found.`);
  }

  const existingProduct = productStore[productIndex];
  // Create a new object for immutability before applying changes
  const updatedProductData = { ...existingProduct };

  // 2. If the product is found, the system validates the updateDetails against business rules.
  if (updateDetails.name != null) {
    if (typeof updateDetails.name !== 'string' || updateDetails.name.trim() === '') {
      throw new Error("Product name cannot be empty.");
    }
    if (!isProductNameUnique(updateDetails.name.trim(), productId)) {
      throw new Error(`Product with name '${updateDetails.name.trim()}' already exists.`);
    }
    updatedProductData.name = updateDetails.name.trim();
  }

  if (updateDetails.description != null) {
    if (typeof updateDetails.description !== 'string' || updateDetails.description.trim() === '') {
      throw new Error("Product description cannot be empty.");
    }
    updatedProductData.description = updateDetails.description.trim();
  }

  if (updateDetails.price != null) {
    if (!isValidPrice(updateDetails.price)) {
      throw new Error("Product price must be a positive number.");
    }
    updatedProductData.price = updateDetails.price;
  }

  if (updateDetails.stock != null) {
    if (!isValidStock(updateDetails.stock)) {
      throw new Error("Product stock must be a non-negative integer.");
    }
    updatedProductData.stock = updateDetails.stock;
  }

  if (updateDetails.category != null) {
    if (typeof updateDetails.category !== 'string' || updateDetails.category.trim() === '') {
      throw new Error("Product category cannot be empty.");
    }
    updatedProductData.category = updateDetails.category.trim();
  }

  if (updateDetails.imageUrl != null) {
    if (typeof updateDetails.imageUrl !== 'string' || updateDetails.imageUrl.trim() === '') {
      throw new Error("Product image URL cannot be empty.");
    }
    updatedProductData.imageUrl = updateDetails.imageUrl.trim();
  }

  // 3. If validation passes, the system applies the changes to the product record.
  // 4. The system persists the modified product record.
  productStore[productIndex] = updatedProductData;

  // 5. The system returns the complete, updated Product object.
  return Product(updatedProductData);
}

/**
 * Removes a product record from the system.
 * @param {string} productId - The unique identifier of the product to delete.
 * @returns {boolean} True if deletion was successful, false otherwise (e.g., product not found).
 */
export function deleteProduct(productId) {
  // 1. The system locates the existing product record using productId.
  const initialLength = productStore.length;
  // 2. If the product is found, the system removes the product record.
  // (Using filter to create a new array, simulating removal)
  productStore = productStore.filter(p => p.id !== productId);

  // 3. The system confirms the outcome of the deletion attempt.
  return productStore.length < initialLength; // True if an item was removed, false if not found
}