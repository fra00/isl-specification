/**
 * ðŸ›‘ DO NOT EDIT THIS FILE DIRECTLY
 * ----------------------------------
 * This file was generated by ISL Compiler.
 * Source: kanban-logic.isl.md
 * Edit the ISL file instead.
 */

import { BoardEntity, ColumnEntity, TaskEntity, PriorityType } from './domain';

// Helper for UUID generation
const generateUUID = () => crypto.randomUUID();

// Helper for date format validation (YYYY-MM-DD)
const isValidDateFormat = (dateString) => {
  if (dateString === null || dateString === undefined || dateString === '') {
    return true; // Empty or null/undefined dueDate is allowed
  }
  return /^\d{4}-\d{2}-\d{2}$/.test(dateString);
};

// Helper for priority validation
const isValidPriority = (priority) => {
  return Object.values(PriorityType).includes(priority);
};

/**
 * Factory function for the Kanban Business Logic module.
 * It encapsulates the board state and provides functions to manipulate it.
 *
 * @param {BoardEntity} initialBoardState - The initial state of the Kanban board.
 * @returns {object} An object containing all Kanban logic capabilities.
 */
export function createKanbanLogic(initialBoardState = BoardEntity()) {
  let _boardState = BoardEntity(initialBoardState); // Internal mutable state
  const _originalInitialBoardState = BoardEntity(initialBoardState); // Store the original initial state for reset

  // Helper to ensure immutability and update the internal state
  const updateBoardState = (newBoard) => {
    _boardState = BoardEntity(newBoard); // Ensure new state is a valid BoardEntity
    return _boardState;
  };

  /**
   * Initializes the Kanban board state with the provided initial data.
   * Resets the board to its original initial state as provided to the factory.
   * @returns {BoardEntity} The current state of the board.
   */
  const initializeBoard = () => {
    return updateBoardState(_originalInitialBoardState);
  };

  /**
   * Adds a new column to the board.
   * @param {string} title - The title of the new column.
   * @returns {BoardEntity} The updated state of the board.
   * @throws {Error} If the title is empty or a column with the same title already exists.
   */
  const addColumn = (title) => {
    if (!title) {
      throw new Error("Column title cannot be empty.");
    }
    if (_boardState.columns.some(col => col.title === title)) {
      throw new Error(`Column with title "${title}" already exists.`);
    }

    const newColumn = ColumnEntity({ id: generateUUID(), title: title, tasks: [] });
    const updatedColumns = [..._boardState.columns, newColumn];
    return updateBoardState({ ..._boardState, columns: updatedColumns });
  };

  /**
   * Renames an existing column.
   * @param {string} columnId - The ID of the column to rename.
   * @param {string} newTitle - The new title for the column.
   * @returns {BoardEntity} The updated state of the board.
   * @throws {Error} If the new title is empty, a column with the new title already exists, or the column is not found.
   */
  const renameColumn = (columnId, newTitle) => {
    if (!newTitle) {
      throw new Error("New column title cannot be empty.");
    }
    if (_boardState.columns.some(col => col.id !== columnId && col.title === newTitle)) {
      throw new Error(`Column with title "${newTitle}" already exists.`);
    }

    let columnFound = false;
    const updatedColumns = _boardState.columns.map(col => {
      if (col.id === columnId) {
        columnFound = true;
        return ColumnEntity({ ...col, title: newTitle });
      }
      return col;
    });

    if (!columnFound) {
      throw new Error(`Column with ID "${columnId}" not found.`);
    }
    return updateBoardState({ ..._boardState, columns: updatedColumns });
  };

  /**
   * Deletes a column and all its tasks from the board.
   * @param {string} columnId - The ID of the column to delete.
   * @returns {BoardEntity} The updated state of the board.
   * @throws {Error} If the column is not found.
   */
  const deleteColumn = (columnId) => {
    const initialColumnCount = _boardState.columns.length;
    const updatedColumns = _boardState.columns.filter(col => col.id !== columnId);

    if (updatedColumns.length === initialColumnCount) {
      throw new Error(`Column with ID "${columnId}" not found.`);
    }
    return updateBoardState({ ..._boardState, columns: updatedColumns });
  };

  /**
   * Adds a new task to a specified column.
   * @param {string} columnId - The ID of the column to add the task to.
   * @param {{ title: string, description: string, dueDate: string, priority: typeof PriorityType[keyof typeof PriorityType] }} taskDetails - Details of the new task.
   * @returns {BoardEntity} The updated state of the board.
   * @throws {Error} If the task title is empty, dueDate format is invalid, priority is invalid, or the column is not found.
   */
  const addTask = (columnId, taskDetails) => {
    const { title, description, dueDate, priority } = taskDetails;

    if (!title) {
      throw new Error("Task title cannot be empty.");
    }
    if (!isValidDateFormat(dueDate)) {
      throw new Error(`Invalid dueDate format. Expected YYYY-MM-DD, got "${dueDate}".`);
    }
    if (!isValidPriority(priority)) {
      throw new Error(`Invalid priority value. Expected one of ${Object.values(PriorityType).join(', ')}, got "${priority}".`);
    }

    const newTask = TaskEntity({
      id: generateUUID(),
      title,
      description: description || '',
      dueDate: dueDate || '',
      priority: priority,
    });

    let columnFound = false;
    const updatedColumns = _boardState.columns.map(col => {
      if (col.id === columnId) {
        columnFound = true;
        return ColumnEntity({ ...col, tasks: [...col.tasks, newTask] });
      }
      return col;
    });

    if (!columnFound) {
      throw new Error(`Column with ID "${columnId}" not found.`);
    }
    return updateBoardState({ ..._boardState, columns: updatedColumns });
  };

  /**
   * Updates the details of an existing task.
   * @param {string} columnId - The ID of the column containing the task.
   * @param {string} taskId - The ID of the task to update.
   * @param {{ title?: string, description?: string, dueDate?: string, priority?: typeof PriorityType[keyof typeof PriorityType] }} updatedDetails - The details to update.
   * @returns {BoardEntity} The updated state of the board.
   * @throws {Error} If dueDate format is invalid, priority is invalid, column is not found, or task is not found.
   */
  const updateTask = (columnId, taskId, updatedDetails) => {
    const { title, description, dueDate, priority } = updatedDetails;

    if (dueDate !== undefined && !isValidDateFormat(dueDate)) {
      throw new Error(`Invalid dueDate format. Expected YYYY-MM-DD, got "${dueDate}".`);
    }
    if (priority !== undefined && !isValidPriority(priority)) {
      throw new Error(`Invalid priority value. Expected one of ${Object.values(PriorityType).join(', ')}, got "${priority}".`);
    }

    let columnFound = false;
    let taskFound = false;
    const updatedColumns = _boardState.columns.map(col => {
      if (col.id === columnId) {
        columnFound = true;
        const updatedTasks = col.tasks.map(task => {
          if (task.id === taskId) {
            taskFound = true;
            return TaskEntity({
              ...task,
              title: title ?? task.title,
              description: description ?? task.description,
              dueDate: dueDate ?? task.dueDate,
              priority: priority ?? task.priority,
            });
          }
          return task;
        });
        return ColumnEntity({ ...col, tasks: updatedTasks });
      }
      return col;
    });

    if (!columnFound) {
      throw new Error(`Column with ID "${columnId}" not found.`);
    }
    if (!taskFound) {
      throw new Error(`Task with ID "${taskId}" not found in column "${columnId}".`);
    }

    return updateBoardState({ ..._boardState, columns: updatedColumns });
  };

  /**
   * Deletes a task from a specified column.
   * @param {string} columnId - The ID of the column containing the task.
   * @param {string} taskId - The ID of the task to delete.
   * @returns {BoardEntity} The updated state of the board.
   * @throws {Error} If the column is not found or the task is not found.
   */
  const deleteTask = (columnId, taskId) => {
    let columnFound = false;
    let taskFound = false;
    const updatedColumns = _boardState.columns.map(col => {
      if (col.id === columnId) {
        columnFound = true;
        const initialTaskCount = col.tasks.length;
        const filteredTasks = col.tasks.filter(task => {
          if (task.id === taskId) {
            taskFound = true;
            return false;
          }
          return true;
        });
        if (filteredTasks.length === initialTaskCount) { // Task not found in this column
            return col;
        }
        return ColumnEntity({ ...col, tasks: filteredTasks });
      }
      return col;
    });

    if (!columnFound) {
      throw new Error(`Column with ID "${columnId}" not found.`);
    }
    if (!taskFound) {
      throw new Error(`Task with ID "${taskId}" not found in column "${columnId}".`);
    }

    return updateBoardState({ ..._boardState, columns: updatedColumns });
  };

  /**
   * Moves a task from its current column to an adjacent column (left or right).
   * @param {string} currentColumnId - The ID of the column the task is currently in.
   * @param {string} taskId - The ID of the task to move.
   * @param {'left' | 'right'} direction - The direction to move the task.
   * @returns {BoardEntity} The updated state of the board.
   * @throws {Error} If the current column or task is not found, or the direction is invalid.
   */
  const moveTask = (currentColumnId, taskId, direction) => {
    const currentColumnIndex = _boardState.columns.findIndex(col => col.id === currentColumnId);

    if (currentColumnIndex === -1) {
      throw new Error(`Current column with ID "${currentColumnId}" not found.`);
    }

    const currentColumn = _boardState.columns[currentColumnIndex];
    const taskToMoveIndex = currentColumn.tasks.findIndex(task => task.id === taskId);

    if (taskToMoveIndex === -1) {
      throw new Error(`Task with ID "${taskId}" not found in column "${currentColumnId}".`);
    }

    let targetColumnIndex = -1;
    if (direction === 'left') {
      targetColumnIndex = currentColumnIndex - 1;
    } else if (direction === 'right') {
      targetColumnIndex = currentColumnIndex + 1;
    } else {
      throw new Error(`Invalid direction: "${direction}". Expected 'left' or 'right'.`);
    }

    // If targetColumnIndex is out of bounds, the task does not move.
    if (targetColumnIndex < 0 || targetColumnIndex >= _boardState.columns.length) {
      return _boardState; // No change, return current state
    }

    const taskToMove = currentColumn.tasks[taskToMoveIndex];

    const newColumns = _boardState.columns.map((col, index) => {
      if (index === currentColumnIndex) {
        // Remove task from current column
        return ColumnEntity({ ...col, tasks: col.tasks.filter(task => task.id !== taskId) });
      } else if (index === targetColumnIndex) {
        // Add task to target column (at the end for simplicity, ISL doesn't specify position)
        return ColumnEntity({ ...col, tasks: [...col.tasks, taskToMove] });
      }
      return col;
    });

    return updateBoardState({ ..._boardState, columns: newColumns });
  };

  /**
   * Retrieves the current state of the Kanban board.
   * @returns {BoardEntity} The current state of the board.
   */
  const getBoardState = () => {
    return _boardState;
  };

  // Return all capabilities as an object
  return {
    initializeBoard,
    addColumn,
    renameColumn,
    deleteColumn,
    addTask,
    updateTask,
    deleteTask,
    moveTask,
    getBoardState,
  };
}