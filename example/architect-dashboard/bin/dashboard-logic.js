/**
 * ðŸ›‘ DO NOT EDIT THIS FILE DIRECTLY
 * ----------------------------------
 * This file was generated by ISL Compiler.
 * Source: dashboard-logic.isl.md
 * Edit the ISL file instead.
 */

// Internal Domain Entity Factories and Data Store (Self-contained as per "codice completo" rule)

/**
 * @typedef {Object} OrderStatus
 * @property {string} PENDING
 * @property {string} PROCESSING
 * @property {string} SHIPPED
 * @property {string} DELIVERED
 * @property {string} CANCELLED
 */
const OrderStatus = {
  PENDING: 'Pending',
  PROCESSING: 'Processing',
  SHIPPED: 'Shipped',
  DELIVERED: 'Delivered',
  CANCELLED: 'Cancelled',
};

/**
 * Factory function for Product entities.
 * @param {object} data - Initial data for the product.
 * @returns {{id: string, name: string, price: number}} A Product entity.
 */
const Product = (data = {}) => ({
  id: '',
  name: '',
  price: 0,
  ...data,
});

/**
 * Factory function for Customer entities.
 * @param {object} data - Initial data for the customer.
 * @returns {{id: string, name: string, creationDate: Date}} A Customer entity.
 */
const Customer = (data = {}) => ({
  id: '',
  name: '',
  creationDate: new Date(),
  ...data,
});

/**
 * Factory function for OrderItem entities.
 * @param {object} data - Initial data for the order item.
 * @returns {{productId: string, productName: string, quantity: number, unitPrice: number, totalPrice: number}} An OrderItem entity.
 */
const OrderItem = (data = {}) => ({
  productId: '',
  productName: '',
  quantity: 0,
  unitPrice: 0,
  totalPrice: 0,
  ...data,
});

/**
 * Factory function for Order entities.
 * @param {object} data - Initial data for the order.
 * @returns {{id: string, customerId: string, orderDate: Date, totalAmount: number, status: string, items: Array<ReturnType<typeof OrderItem>>}} An Order entity.
 */
const Order = (data = {}) => ({
  id: '',
  customerId: '',
  orderDate: new Date(),
  totalAmount: 0,
  status: OrderStatus.PENDING,
  items: [],
  ...data,
});

// --- Internal In-Memory Data Store (for demonstration and completeness) ---
// This simulates a data access layer as none was provided.
// All dates are UTC for consistency.

const customersData = [
  Customer({ id: 'C1', name: 'Alice Smith', creationDate: new Date('2023-01-15T10:00:00Z') }),
  Customer({ id: 'C2', name: 'Bob Johnson', creationDate: new Date('2023-02-20T11:30:00Z') }),
  Customer({ id: 'C3', name: 'Charlie Brown', creationDate: new Date('2024-03-01T12:00:00Z') }), // New customer in March 2024
  Customer({ id: 'C4', name: 'Diana Prince', creationDate: new Date('2024-03-05T14:00:00Z') }), // New customer in March 2024
  Customer({ id: 'C5', name: 'Eve Adams', creationDate: new Date('2024-04-10T09:00:00Z') }), // New customer in April 2024
  Customer({ id: 'C6', name: 'Frank White', creationDate: new Date('2024-04-12T10:00:00Z') }), // New customer in April 2024
];

const productsData = [
  Product({ id: 'P1', name: 'Laptop Pro', price: 1200.00 }),
  Product({ id: 'P2', name: 'Wireless Mouse', price: 25.00 }),
  Product({ id: 'P3', name: 'Mechanical Keyboard', price: 75.00 }),
  Product({ id: 'P4', name: 'Monitor 27-inch', price: 300.00 }),
  Product({ id: 'P5', name: 'USB-C Hub', price: 40.00 }),
];

const ordersData = [
  Order({
    id: 'O1', customerId: 'C1', orderDate: new Date('2024-02-28T10:00:00Z'), totalAmount: 1225.00, status: OrderStatus.DELIVERED,
    items: [
      OrderItem({ productId: 'P1', productName: 'Laptop Pro', quantity: 1, unitPrice: 1200.00, totalPrice: 1200.00 }),
      OrderItem({ productId: 'P2', productName: 'Wireless Mouse', quantity: 1, unitPrice: 25.00, totalPrice: 25.00 }),
    ],
  }),
  Order({
    id: 'O2', customerId: 'C2', orderDate: new Date('2024-03-02T11:00:00Z'), totalAmount: 75.00, status: OrderStatus.SHIPPED,
    items: [
      OrderItem({ productId: 'P3', productName: 'Mechanical Keyboard', quantity: 1, unitPrice: 75.00, totalPrice: 75.00 }),
    ],
  }),
  Order({
    id: 'O3', customerId: 'C3', orderDate: new Date('2024-03-03T12:00:00Z'), totalAmount: 340.00, status: OrderStatus.PROCESSING,
    items: [
      OrderItem({ productId: 'P4', productName: 'Monitor 27-inch', quantity: 1, unitPrice: 300.00, totalPrice: 300.00 }),
      OrderItem({ productId: 'P5', productName: 'USB-C Hub', quantity: 1, unitPrice: 40.00, totalPrice: 40.00 }),
    ],
  }),
  Order({
    id: 'O4', customerId: 'C4', orderDate: new Date('2024-03-06T13:00:00Z'), totalAmount: 1200.00, status: OrderStatus.DELIVERED,
    items: [
      OrderItem({ productId: 'P1', productName: 'Laptop Pro', quantity: 1, unitPrice: 1200.00, totalPrice: 1200.00 }),
    ],
  }),
  Order({
    id: 'O5', customerId: 'C5', orderDate: new Date('2024-04-11T14:00:00Z'), totalAmount: 50.00, status: OrderStatus.PENDING,
    items: [
      OrderItem({ productId: 'P2', productName: 'Wireless Mouse', quantity: 2, unitPrice: 25.00, totalPrice: 50.00 }),
    ],
  }),
  Order({
    id: 'O6', customerId: 'C6', orderDate: new Date('2024-04-13T15:00:00Z'), totalAmount: 1275.00, status: OrderStatus.PROCESSING,
    items: [
      OrderItem({ productId: 'P1', productName: 'Laptop Pro', quantity: 1, unitPrice: 1200.00, totalPrice: 1200.00 }),
      OrderItem({ productId: 'P3', productName: 'Mechanical Keyboard', quantity: 1, unitPrice: 75.00, totalPrice: 75.00 }),
    ],
  }),
  Order({
    id: 'O7', customerId: 'C1', orderDate: new Date('2024-04-14T16:00:00Z'), totalAmount: 300.00, status: OrderStatus.SHIPPED,
    items: [
      OrderItem({ productId: 'P4', productName: 'Monitor 27-inch', quantity: 1, unitPrice: 300.00, totalPrice: 300.00 }),
    ],
  }),
  Order({
    id: 'O8', customerId: 'C2', orderDate: new Date('2024-04-15T17:00:00Z'), totalAmount: 40.00, status: OrderStatus.DELIVERED,
    items: [
      OrderItem({ productId: 'P5', productName: 'USB-C Hub', quantity: 1, unitPrice: 40.00, totalPrice: 40.00 }),
    ],
  }),
  Order({
    id: 'O9', customerId: 'C3', orderDate: new Date('2024-04-16T18:00:00Z'), totalAmount: 1200.00, status: OrderStatus.PENDING,
    items: [
      OrderItem({ productId: 'P1', productName: 'Laptop Pro', quantity: 1, unitPrice: 1200.00, totalPrice: 1200.00 }),
    ],
  }),
  Order({
    id: 'O10', customerId: 'C4', orderDate: new Date('2024-04-17T19:00:00Z'), totalAmount: 25.00, status: OrderStatus.PROCESSING,
    items: [
      OrderItem({ productId: 'P2', productName: 'Wireless Mouse', quantity: 1, unitPrice: 25.00, totalPrice: 25.00 }),
    ],
  }),
];

// --- Helper Functions for Date Calculations ---

/**
 * Sets a Date object to the start of the day (00:00:00.000 UTC).
 * @param {Date} date - The date to modify.
 * @returns {Date} A new Date object set to the start of the day.
 */
const startOfDay = (date) => {
  const d = new Date(date);
  d.setUTCHours(0, 0, 0, 0);
  return d;
};

/**
 * Sets a Date object to the end of the day (23:59:59.999 UTC).
 * @param {Date} date - The date to modify.
 * @returns {Date} A new Date object set to the end of the day.
 */
const endOfDay = (date) => {
  const d = new Date(date);
  d.setUTCHours(23, 59, 59, 999);
  return d;
};

/**
 * Calculates start and end dates based on a period string or custom dates.
 * @param {string} period - The predefined period (e.g., "last30days", "currentMonth").
 * @param {Date} [customStartDate] - Custom start date (required for "custom" period).
 * @param {Date} [customEndDate] - Custom end date (required for "custom" period).
 * @returns {{startDate: Date, endDate: Date}} An object containing the calculated start and end dates.
 * @throws {Error} If "custom" period is used without valid start/end dates.
 */
const getDatesForPeriod = (period, customStartDate, customEndDate) => {
  const now = new Date();
  let startDate = new Date();
  let endDate = new Date();

  switch (period) {
    case 'today':
      startDate = startOfDay(now);
      endDate = endOfDay(now);
      break;
    case 'yesterday':
      startDate.setUTCDate(now.getUTCDate() - 1);
      endDate.setUTCDate(now.getUTCDate() - 1);
      startDate = startOfDay(startDate);
      endDate = endOfDay(endDate);
      break;
    case 'last7days':
      startDate.setUTCDate(now.getUTCDate() - 6); // Includes today
      startDate = startOfDay(startDate);
      endDate = endOfDay(now);
      break;
    case 'last30days':
      startDate.setUTCDate(now.getUTCDate() - 29); // Includes today
      startDate = startOfDay(startDate);
      endDate = endOfDay(now);
      break;
    case 'thisMonth':
      startDate = startOfDay(new Date(now.getUTCFullYear(), now.getUTCMonth(), 1));
      endDate = endOfDay(now);
      break;
    case 'lastMonth':
      startDate = startOfDay(new Date(now.getUTCFullYear(), now.getUTCMonth() - 1, 1));
      endDate = endOfDay(new Date(now.getUTCFullYear(), now.getUTCMonth(), 0)); // Last day of previous month
      break;
    case 'thisYear':
      startDate = startOfDay(new Date(now.getUTCFullYear(), 0, 1));
      endDate = endOfDay(now);
      break;
    case 'last12months': // For sales trend, typically means 12 full months ending last month
      endDate = endOfDay(new Date(now.getUTCFullYear(), now.getUTCMonth(), 0)); // End of last month
      startDate = startOfDay(new Date(endDate.getUTCFullYear(), endDate.getUTCMonth() - 11, 1)); // 12 months before that
      break;
    case 'allTime':
      startDate = new Date(0); // Unix epoch start
      endDate = endOfDay(now);
      break;
    case 'custom':
      if (!customStartDate || !customEndDate) {
        throw new Error('For "custom" timeframe, startDate and endDate must be provided.');
      }
      startDate = startOfDay(new Date(customStartDate));
      endDate = endOfDay(new Date(customEndDate));
      break;
    default:
      // Default to last 30 days if period is unrecognized
      startDate.setUTCDate(now.getUTCDate() - 29);
      startDate = startOfDay(startDate);
      endDate = endOfDay(now);
      break;
  }

  return { startDate, endDate };
};

/**
 * Formats a Date object to an ISO string (YYYY-MM-DD).
 * @param {Date} date - The date to format.
 * @returns {string} The formatted date string.
 */
const formatDateToISO = (date) => date.toISOString().split('T')[0];

/**
 * Formats a Date object to a YYYY-MM string.
 * @param {Date} date - The date to format.
 * @returns {string} The formatted month string.
 */
const formatDateToMonth = (date) => date.toISOString().substring(0, 7);

// --- Business Logic Capabilities ---

/**
 * Retrieves key performance indicators (KPIs) for the dashboard.
 * @param {string} period - The specified period (e.g., "last30days").
 * @returns {{totalSales: number, totalOrders: number, averageOrderValue: number, newCustomers: number}} Dashboard KPIs.
 */
export function getDashboardSummaryKPIs(period) {
  // 1. Identify the start and end dates based on the period input.
  const { startDate, endDate } = getDatesForPeriod(period);

  // 2. Retrieve all Order entities that fall within the identified date range.
  const relevantOrders = ordersData.filter(order =>
    order.orderDate >= startDate && order.orderDate <= endDate
  );

  // 3. Calculate totalSales by summing the totalAmount of all relevant Order entities.
  const totalSales = relevantOrders.reduce((sum, order) => sum + order.totalAmount, 0);

  // 4. Calculate totalOrders by counting the number of relevant Order entities.
  const totalOrders = relevantOrders.length;

  // 5. Calculate averageOrderValue by dividing totalSales by totalOrders. If totalOrders is zero, averageOrderValue is zero.
  const averageOrderValue = totalOrders > 0 ? totalSales / totalOrders : 0;

  // 6. Retrieve all Customer entities whose creationDate falls within the identified date range.
  const newCustomers = customersData.filter(customer =>
    customer.creationDate >= startDate && customer.creationDate <= endDate
  ).length;

  // 8. Return the calculated DashboardKPIs.
  return {
    totalSales: parseFloat(totalSales.toFixed(2)),
    totalOrders: totalOrders,
    averageOrderValue: parseFloat(averageOrderValue.toFixed(2)),
    newCustomers: newCustomers,
  };
}

/**
 * Provides sales data aggregated over a specified time granularity for a given period.
 * @param {string} period - The specified period (e.g., "last30days", "last12months").
 * @param {string} granularity - The aggregation granularity (e.g., "daily", "monthly").
 * @returns {Array<{date: string, sales: number}>} Sales trend data.
 */
export function getSalesTrendData(period, granularity) {
  // 1. Determine the start and end dates based on the period input.
  const { startDate, endDate } = getDatesForPeriod(period);

  // 2. Retrieve all Order entities within the determined date range.
  const relevantOrders = ordersData.filter(order =>
    order.orderDate >= startDate && order.orderDate <= endDate
  );

  const salesByPeriod = new Map();

  // 3. Aggregate the totalAmount of these Order entities based on the granularity.
  relevantOrders.forEach(order => {
    let key;
    if (granularity === 'daily') {
      key = formatDateToISO(order.orderDate);
    } else if (granularity === 'monthly') {
      key = formatDateToMonth(order.orderDate);
    } else {
      // Default to daily if granularity is unrecognized
      key = formatDateToISO(order.orderDate);
    }
    salesByPeriod.set(key, (salesByPeriod.get(key) || 0) + order.totalAmount);
  });

  // Ensure all periods within the range are present, even if sales are zero
  const trendData = [];
  let currentDate = new Date(startDate);
  while (currentDate <= endDate) {
    let key;
    if (granularity === 'daily') {
      key = formatDateToISO(currentDate);
    } else if (granularity === 'monthly') {
      key = formatDateToMonth(currentDate);
    } else {
      key = formatDateToISO(currentDate);
    }

    if (!salesByPeriod.has(key)) {
      salesByPeriod.set(key, 0);
    }

    if (granularity === 'daily') {
      currentDate.setUTCDate(currentDate.getUTCDate() + 1);
    } else if (granularity === 'monthly') {
      currentDate.setUTCMonth(currentDate.getUTCMonth() + 1);
      currentDate.setUTCDate(1); // Reset day to 1 to avoid issues with short months
    } else {
      currentDate.setUTCDate(currentDate.getUTCDate() + 1);
    }
  }

  // 4. Format the aggregated data into an array of objects.
  Array.from(salesByPeriod.entries())
    .sort(([dateA], [dateB]) => dateA.localeCompare(dateB))
    .forEach(([date, sales]) => {
      trendData.push({ date: date, sales: parseFloat(sales.toFixed(2)) });
    });

  // 5. Return the SalesTrendData.
  return trendData;
}

/**
 * Identifies and lists the top N products based on their total sales quantity or revenue within a specified period.
 * @param {string} period - The specified period (e.g., "last30days", "allTime").
 * @param {number} limit - Maximum number of products to return.
 * @returns {Array<{productId: string, productName: string, totalQuantitySold: number, totalRevenue: number}>} Top selling products list.
 */
export function getTopSellingProducts(period, limit) {
  // 1. Determine the start and end dates based on the period input.
  const { startDate, endDate } = getDatesForPeriod(period);

  // 2. Retrieve all Order entities within the determined date range.
  const relevantOrders = ordersData.filter(order =>
    order.orderDate >= startDate && order.orderDate <= endDate
  );

  const productAggregates = new Map(); // Map: productId -> { productName, totalQuantitySold, totalRevenue }

  // 3. For each Order, iterate through its items to extract Product information, quantity, and individual item revenue.
  relevantOrders.forEach(order => {
    order.items.forEach(item => {
      const { productId, productName, quantity, totalPrice } = item;
      const current = productAggregates.get(productId) || {
        productId: productId,
        productName: productName,
        totalQuantitySold: 0,
        totalRevenue: 0,
      };

      current.totalQuantitySold += quantity;
      current.totalRevenue += totalPrice;
      productAggregates.set(productId, current);
    });
  });

  // 4. Aggregate the total quantity sold and total revenue for each unique Product. (Done in step 3)

  // 5. Sort the aggregated products by totalRevenue (or totalQuantitySold if revenue is equal) in descending order.
  const sortedProducts = Array.from(productAggregates.values()).sort((a, b) => {
    if (b.totalRevenue !== a.totalRevenue) {
      return b.totalRevenue - a.totalRevenue;
    }
    return b.totalQuantitySold - a.totalQuantitySold;
  });

  // 6. Limit the result to the specified limit.
  const topProducts = sortedProducts.slice(0, limit).map(p => ({
    ...p,
    totalRevenue: parseFloat(p.totalRevenue.toFixed(2)),
  }));

  // 7. Return the TopSellingProducts list.
  return topProducts;
}

/**
 * Calculates the count and percentage of orders for each OrderStatus.
 * @returns {Array<{status: string, count: number, percentage: number}>} Order status distribution.
 */
export function getOrderStatusDistribution() {
  // 1. Retrieve all Order entities.
  const allOrders = ordersData;

  // 2. Count the total number of Order entities.
  const totalOrders = allOrders.length;

  const statusCounts = {};
  Object.values(OrderStatus).forEach(status => {
    statusCounts[status] = 0; // Initialize all possible statuses to 0
  });

  // 3. Group Order entities by their Order.status.
  allOrders.forEach(order => {
    statusCounts[order.status] = (statusCounts[order.status] || 0) + 1;
  });

  // 4. For each OrderStatus, calculate the count of orders and its percentage relative to the total number of orders.
  const distribution = Object.keys(statusCounts).map(status => {
    const count = statusCounts[status];
    const percentage = totalOrders > 0 ? (count / totalOrders) * 100 : 0;
    return {
      status: status,
      count: count,
      percentage: parseFloat(percentage.toFixed(2)), // Round to 2 decimal places for display
    };
  });

  // 5. Return the OrderStatusDistribution.
  return distribution;
}

/**
 * Provides a comprehensive overview of key dashboard metrics.
 * @param {string} timeframe - The specified timeframe (e.g., "last7days", "custom").
 * @param {Date} [startDate] - Custom start date (required if timeframe is "custom").
 * @param {Date} [endDate] - Custom end date (required if timeframe is "custom").
 * @returns {{totalSales: number, totalOrders: number, averageOrderValue: number, newCustomers: number, salesTrendData: Array<{date: string, sales: number}>, orderStatusDistribution: Array<{status: string, count: number}>, topSellingProducts: Array<{productId: string, name: string, quantitySold: number, totalRevenue: number}>, recentOrders: Array<{orderId: string, customerName: string, orderDate: Date, totalAmount: number, status: string}>}} Dashboard overview data.
 */
export function getDashboardOverview(timeframe, startDate, endDate) {
  // 1. Determine the effective startDate and endDate based on the timeframe input.
  const { startDate: effectiveStartDate, endDate: effectiveEndDate } = getDatesForPeriod(timeframe, startDate, endDate);

  // 2. Retrieve all Order entities that fall within the determined startDate and endDate.
  const relevantOrders = ordersData.filter(order =>
    order.orderDate >= effectiveStartDate && order.orderDate <= effectiveEndDate
  );

  // 3. Retrieve all Customer entities whose creationDate falls within the determined startDate and endDate.
  const relevantCustomers = customersData.filter(customer =>
    customer.creationDate >= effectiveStartDate && customer.creationDate <= effectiveEndDate
  );

  // 4. Calculate Summary KPIs:
  const totalSales = relevantOrders.reduce((sum, order) => sum + order.totalAmount, 0);
  const totalOrders = relevantOrders.length;
  const averageOrderValue = totalOrders > 0 ? totalSales / totalOrders : 0;

  // 5. Calculate New Customers:
  const newCustomers = relevantCustomers.length;

  // 6. Calculate Sales Trend Data (daily aggregation for overview):
  const salesByDay = new Map();
  relevantOrders.forEach(order => {
    const dateKey = formatDateToISO(order.orderDate);
    salesByDay.set(dateKey, (salesByDay.get(dateKey) || 0) + order.totalAmount);
  });

  const salesTrendData = [];
  let currentTrendDate = new Date(effectiveStartDate);
  while (currentTrendDate <= effectiveEndDate) {
    const dateKey = formatDateToISO(currentTrendDate);
    salesTrendData.push({
      date: currentTrendDate, // Return as Date object as per signature
      sales: parseFloat((salesByDay.get(dateKey) || 0).toFixed(2)),
    });
    currentTrendDate.setUTCDate(currentTrendDate.getUTCDate() + 1);
  }

  // 7. Calculate Order Status Distribution:
  const orderStatusCounts = {};
  Object.values(OrderStatus).forEach(status => {
    orderStatusCounts[status] = 0; // Initialize all possible statuses to 0
  });
  relevantOrders.forEach(order => {
    orderStatusCounts[order.status] = (orderStatusCounts[order.status] || 0) + 1;
  });
  const orderStatusDistribution = Object.keys(orderStatusCounts).map(status => ({
    status: status,
    count: orderStatusCounts[status],
  }));

  // 8. Calculate Top Selling Products:
  const productAggregates = new Map();
  relevantOrders.forEach(order => {
    order.items.forEach(item => {
      const { productId, productName, quantity, totalPrice } = item;
      const current = productAggregates.get(productId) || {
        productId: productId,
        name: productName, // Use 'name' as per output signature
        quantitySold: 0, // Use 'quantitySold' as per output signature
        totalRevenue: 0,
      };
      current.quantitySold += quantity;
      current.totalRevenue += totalPrice;
      productAggregates.set(productId, current);
    });
  });
  const topSellingProducts = Array.from(productAggregates.values())
    .sort((a, b) => b.totalRevenue - a.totalRevenue)
    .map(p => ({
      ...p,
      totalRevenue: parseFloat(p.totalRevenue.toFixed(2)),
    }));

  // 9. Retrieve Recent Orders:
  const recentOrdersLimit = 10; // Predefined number of recent orders
  const sortedRecentOrders = [...relevantOrders]
    .sort((a, b) => b.orderDate.getTime() - a.orderDate.getTime())
    .slice(0, recentOrdersLimit);

  const customerMap = new Map(customersData.map(c => [c.id, c.name]));
  const recentOrders = sortedRecentOrders.map(order => ({
    orderId: order.id,
    customerName: customerMap.get(order.customerId) || 'Unknown Customer',
    orderDate: order.orderDate,
    totalAmount: parseFloat(order.totalAmount.toFixed(2)),
    status: order.status,
  }));

  // 10. Return the complete DashboardOverview object.
  return {
    totalSales: parseFloat(totalSales.toFixed(2)),
    totalOrders: totalOrders,
    averageOrderValue: parseFloat(averageOrderValue.toFixed(2)),
    newCustomers: newCustomers,
    salesTrendData: salesTrendData,
    orderStatusDistribution: orderStatusDistribution,
    topSellingProducts: topSellingProducts,
    recentOrders: recentOrders,
  };
}