/**
 * ðŸ›‘ DO NOT EDIT THIS FILE DIRECTLY
 * ----------------------------------
 * This file was generated by ISL Compiler.
 * Source: game-board-presentation.isl.md
 * Edit the ISL file instead.
 */

import React, { useRef, useEffect, useCallback } from 'react';
import { PlayerActionEnum } from './game-domain';

export default function GameBoardPresentation({ gameState, gameConfig, onPlayerAction }) {
  const canvasRef = useRef(null);

  // Capability: renderGameElements
  // Contract: Draws all active game entities onto the game board canvas.
  const renderGameElements = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // 1. Clear the entire canvas area to prepare for the new frame.
    ctx.clearRect(0, 0, gameConfig.canvasWidth, gameConfig.canvasHeight);
    ctx.fillStyle = 'black'; // Background color
    ctx.fillRect(0, 0, gameConfig.canvasWidth, gameConfig.canvasHeight);

    // 2. Draw the player ship
    const player = gameState.playerState;
    if (player) {
      ctx.fillStyle = 'lime'; // Player color
      ctx.fillRect(player.position.x, player.position.y, player.size.width, player.size.height);
    }

    // 3. FOR EACH invader in gameState.invadersState
    gameState.invadersState?.forEach(invader => {
      if (invader.isAlive) {
        ctx.fillStyle = 'red'; // Invader color
        ctx.fillRect(invader.position.x, invader.position.y, invader.size.width, invader.size.height);
      }
    });

    // 4. FOR EACH playerBullet in gameState.playerBullets
    gameState.playerBullets?.forEach(bullet => {
      if (bullet.isAlive) {
        ctx.fillStyle = 'yellow'; // Player bullet color
        ctx.fillRect(bullet.position.x, bullet.position.y, bullet.size.width, bullet.size.height);
      }
    });

    // 5. FOR EACH invaderBullet in gameState.invaderBullets
    gameState.invaderBullets?.forEach(bullet => {
      if (bullet.isAlive) {
        ctx.fillStyle = 'orange'; // Invader bullet color
        ctx.fillRect(bullet.position.x, bullet.position.y, bullet.size.width, bullet.size.height);
      }
    });

    // 6. FOR EACH shieldSegment in gameState.shieldStates
    gameState.shieldStates?.forEach(segment => {
      if (!segment.isDestroyed && segment.health > 0) {
        // Visual representation of health (e.g., by changing color or opacity)
        const healthRatio = segment.health / gameConfig.shieldSegmentHealth;
        let color;
        if (healthRatio > 0.66) {
          color = 'rgba(0, 0, 255, 1)'; // High health: Blue
        } else if (healthRatio > 0.33) {
          color = 'rgba(0, 0, 255, 0.6)'; // Medium health: Lighter blue
        } else {
          color = 'rgba(0, 0, 255, 0.3)'; // Low health: Very light blue
        }
        ctx.fillStyle = color;
        ctx.fillRect(segment.position.x, segment.position.y, segment.size.width, segment.size.height);
      }
    });
  }, [gameState, gameConfig]); // Re-render when gameState or gameConfig changes

  // Effect for drawing
  useEffect(() => {
    renderGameElements();
  }, [renderGameElements]);

  // Capability: handleKeyboardInput
  // Contract: Captures keyboard events and translates them into abstract player actions.
  useEffect(() => {
    const handleKeyDown = (event) => {
      // Prevent default behavior for game keys to avoid scrolling, etc.
      if (['ArrowLeft', 'ArrowRight', 'a', 'A', 'd', 'D', ' '].includes(event.key)) {
        event.preventDefault();
      }

      switch (event.key) {
        case 'ArrowLeft':
        case 'a':
        case 'A':
          onPlayerAction(PlayerActionEnum.MOVE_LEFT, true);
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          onPlayerAction(PlayerActionEnum.MOVE_RIGHT, true);
          break;
        case ' ': // Spacebar
          onPlayerAction(PlayerActionEnum.SHOOT, true);
          break;
        default:
          break;
      }
    };

    const handleKeyUp = (event) => {
      switch (event.key) {
        case 'ArrowLeft':
        case 'a':
        case 'A':
          onPlayerAction(PlayerActionEnum.MOVE_LEFT, false);
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          onPlayerAction(PlayerActionEnum.MOVE_RIGHT, false);
          break;
        case ' ': // Spacebar
          onPlayerAction(PlayerActionEnum.SHOOT, false);
          break;
        default:
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [onPlayerAction]); // Depend on onPlayerAction to ensure stability

  return (
    <div className="flex justify-center items-center bg-gray-900 p-4">
      <canvas
        ref={canvasRef}
        width={gameConfig.canvasWidth}
        height={gameConfig.canvasHeight}
        className="border-2 border-white bg-black"
      >
        Your browser does not support the HTML5 canvas tag.
      </canvas>
    </div>
  );
}