/**
 * ðŸ›‘ DO NOT EDIT THIS FILE DIRECTLY
 * ----------------------------------
 * This file was generated by ISL Compiler.
 * Source: order-logic.isl.md
 * Edit the ISL file instead.
 */

// --- Domain Factories (Self-defined based on ISL usage and common patterns) ---
// These are assumed to be from `./domain.isl.md` as per the references.
// Since no actual dependency interface was provided, we define them here.

export const OrderStatus = {
  PENDING: 'Pending',
  PROCESSING: 'Processing',
  SHIPPED: 'Shipped',
  DELIVERED: 'Delivered',
  CANCELLED: 'Cancelled',
  RETURNED: 'Returned',
};

export const OrderItem = ({ productId, quantity, price, returnedQuantity = 0 }) => ({
  productId,
  quantity,
  price,
  returnedQuantity,
});

export const Order = ({
  id,
  customerId,
  status = OrderStatus.PENDING,
  items = [],
  totalAmount = 0,
  date = new Date().toISOString(),
}) => ({
  id,
  customerId,
  status,
  items: items.map(item => OrderItem(item)),
  totalAmount,
  date,
});

export const ReturnConfirmation = ({ orderId, returnedItems = [], refundAmount = 0 }) => ({
  orderId,
  returnedItems,
  refundAmount,
});

// --- Internal Data Store Simulation ---
// In a real application, this would be an API call or a database interaction.
// For this business logic component, we simulate an in-memory store.
let orders = [
  Order({
    id: 'ORD001',
    customerId: 'CUST001',
    status: OrderStatus.PENDING,
    items: [
      OrderItem({ productId: 'PROD001', quantity: 2, price: 100 }),
      OrderItem({ productId: 'PROD002', quantity: 1, price: 50 }),
    ],
    totalAmount: 250,
    date: '2023-01-15T10:00:00Z',
  }),
  Order({
    id: 'ORD002',
    customerId: 'CUST002',
    status: OrderStatus.SHIPPED,
    items: [
      OrderItem({ productId: 'PROD003', quantity: 1, price: 300, returnedQuantity: 0 }),
      OrderItem({ productId: 'PROD001', quantity: 1, price: 100, returnedQuantity: 0 }),
    ],
    totalAmount: 400,
    date: '2023-01-10T11:30:00Z',
  }),
  Order({
    id: 'ORD003',
    customerId: 'CUST001',
    status: OrderStatus.DELIVERED,
    items: [
      OrderItem({ productId: 'PROD004', quantity: 3, price: 20, returnedQuantity: 1 }),
    ],
    totalAmount: 60,
    date: '2023-01-20T14:00:00Z',
  }),
  Order({
    id: 'ORD004',
    customerId: 'CUST003',
    status: OrderStatus.CANCELLED,
    items: [
      OrderItem({ productId: 'PROD005', quantity: 1, price: 500 }),
    ],
    totalAmount: 500,
    date: '2023-01-22T09:00:00Z',
  }),
];

// --- Helper for Status Transitions ---
const validStatusTransitions = {
  [OrderStatus.PENDING]: [OrderStatus.PROCESSING, OrderStatus.CANCELLED],
  [OrderStatus.PROCESSING]: [OrderStatus.SHIPPED, OrderStatus.CANCELLED],
  [OrderStatus.SHIPPED]: [OrderStatus.DELIVERED, OrderStatus.RETURNED],
  [OrderStatus.DELIVERED]: [OrderStatus.RETURNED],
  [OrderStatus.CANCELLED]: [],
  [OrderStatus.RETURNED]: [],
};

const isValidStatusTransition = (currentStatus, newStatus) => {
  return validStatusTransitions[currentStatus]?.includes(newStatus) || false;
};

// --- Business Logic Capabilities ---

export async function fetchOrders(filters = {}, pagination = {}) {
  // 1. Receive filtering and pagination parameters.
  let filteredOrders = [...orders];

  // 2. Query the underlying data store for orders that match the provided `filters`.
  if (filters.status) {
    filteredOrders = filteredOrders.filter(order => order.status === filters.status);
  }
  if (filters.customerId) {
    filteredOrders = filteredOrders.filter(order => order.customerId === filters.customerId);
  }
  if (filters.dateRange?.start && filters.dateRange?.end) {
    const startDate = new Date(filters.dateRange.start);
    const endDate = new Date(filters.dateRange.end);
    filteredOrders = filteredOrders.filter(order => {
      const orderDate = new Date(order.date);
      return orderDate >= startDate && orderDate <= endDate;
    });
  }

  const totalCount = filteredOrders.length;

  // 3. Apply `pagination` to the results.
  const { page = 1, pageSize = 10 } = pagination;
  const startIndex = (page - 1) * pageSize;
  const endIndex = startIndex + pageSize;
  const paginatedOrders = filteredOrders.slice(startIndex, endIndex);

  // 4. Return the paginated list of `Order` objects and the `totalCount`.
  return { orders: paginatedOrders, totalCount };
}

export async function fetchOrderById(orderId) {
  // 1. Receive the `orderId`.

  // 2. Query the underlying data store for an order matching the `orderId`.
  const order = orders.find(o => o.id === orderId);

  // 3. Return the found `Order` object or indicate its absence.
  return order ? Order(order) : null;
}

export async function updateOrderStatus(orderId, newStatus) {
  // 1. Receive the `orderId` and `newStatus`.

  // 2. Retrieve the existing order using `orderId`.
  const orderIndex = orders.findIndex(o => o.id === orderId);
  if (orderIndex === -1) {
    throw new Error(`Order with ID ${orderId} not found.`);
  }

  const existingOrder = orders[orderIndex];

  // 3. Validate that the `newStatus` is a valid transition from the current order status.
  if (!isValidStatusTransition(existingOrder.status, newStatus)) {
    throw new Error(`Invalid status transition from ${existingOrder.status} to ${newStatus} for order ${orderId}.`);
  }

  // 4. Update the order's status to `newStatus`.
  const updatedOrder = Order({ ...existingOrder, status: newStatus });

  // 5. Persist the updated order information to the data store.
  orders = [...orders.slice(0, orderIndex), updatedOrder, ...orders.slice(orderIndex + 1)];

  // 6. Return the `updatedOrder`.
  return updatedOrder;
}

export async function processOrderReturn(orderId, itemsToReturn, returnReason) {
  // 1. Receive `orderId`, `itemsToReturn`, and `returnReason`.

  // 2. Retrieve the existing order using `orderId`.
  const orderIndex = orders.findIndex(o => o.id === orderId);
  if (orderIndex === -1) {
    throw new Error(`Order with ID ${orderId} not found.`);
  }

  const existingOrder = orders[orderIndex];
  let refundAmount = 0;
  const successfullyReturnedItems = [];
  let newOrderItems = existingOrder.items.map(item => OrderItem(item));

  // 3. Validate that the specified `itemsToReturn` exist within the order and their quantities are available for return.
  for (const itemToReturn of itemsToReturn) {
    const orderItem = newOrderItems.find(oi => oi.productId === itemToReturn.productId);

    if (!orderItem) {
      throw new Error(`Product ${itemToReturn.productId} not found in order ${orderId}.`);
    }

    const availableForReturn = orderItem.quantity - orderItem.returnedQuantity;
    if (itemToReturn.quantity <= 0 || itemToReturn.quantity > availableForReturn) {
      throw new Error(
        `Invalid return quantity for product ${itemToReturn.productId}. Requested: ${itemToReturn.quantity}, Available: ${availableForReturn}.`
      );
    }

    // 4. Calculate the `refundAmount` based on the returned items and original purchase prices.
    refundAmount += itemToReturn.quantity * orderItem.price;

    // 5. Update the order's internal state to reflect the returned items.
    const updatedOrderItem = OrderItem({
      ...orderItem,
      returnedQuantity: orderItem.returnedQuantity + itemToReturn.quantity,
    });
    newOrderItems = newOrderItems.map(oi =>
      oi.productId === updatedOrderItem.productId ? updatedOrderItem : oi
    );

    successfullyReturnedItems.push({
      productId: itemToReturn.productId,
      quantity: itemToReturn.quantity,
    });
  }

  // Check if all items in the order are now fully returned.
  const allItemsFullyReturned = newOrderItems.every(item => item.quantity === item.returnedQuantity);
  const newOrderStatus = allItemsFullyReturned ? OrderStatus.RETURNED : existingOrder.status;

  const updatedOrder = Order({
    ...existingOrder,
    items: newOrderItems,
    status: newOrderStatus,
  });

  // 6. Persist the updated order information.
  orders = [...orders.slice(0, orderIndex), updatedOrder, ...orders.slice(orderIndex + 1)];

  // 7. Generate a `returnConfirmation` record.
  const returnConfirmation = ReturnConfirmation({
    orderId,
    returnedItems: successfullyReturnedItems,
    refundAmount,
  });

  // 8. Return the `returnConfirmation`.
  return returnConfirmation;
}