/**
 * ðŸ›‘ DO NOT EDIT THIS FILE DIRECTLY
 * ----------------------------------
 * This file was generated by ISL Compiler.
 * Source: logic.isl.md
 * Edit the ISL file instead.
 */

import { TimerMode, TimerState, TimerConfigEntity } from "./domain";

/**
 * PomodoroEngine is a factory function that creates an instance of the pomodoro logic.
 * It encapsulates the state and provides methods to interact with it.
 *
 * @param {object} initialConfig - The initial configuration for timer durations.
 * @returns {object} An object containing the timer's capabilities and state getters.
 */
export const PomodoroEngine = (initialConfig) => {
  // Internal state variables, accessible within the closure
  let currentMode = TimerMode.Work;
  let currentState = TimerState.Idle;
  let remainingTime = 0;
  // Use the TimerConfigEntity factory to ensure default values are applied
  let config = TimerConfigEntity(initialConfig);
  let timerIntervalId = null; // To store the ID returned by setInterval

  /**
   * Stops any active periodic tick operations.
   * This ensures only one interval is running at a time and cleans up resources.
   */
  const stopTickOperations = () => {
    if (timerIntervalId !== null) {
      clearInterval(timerIntervalId);
      timerIntervalId = null;
    }
  };

  /**
   * Internal capability: Decrements the remaining time and handles state transitions when time runs out.
   * This function is called periodically by `setInterval`.
   */
  const tick = () => {
    if (currentState === TimerState.Running) {
      // Decrement remainingTime by 1 second, ensuring it never goes below 0.
      remainingTime = Math.max(0, remainingTime - 1);

      // If time runs out, transition to Completed state and stop the timer.
      if (remainingTime <= 0) {
        remainingTime = 0; // Ensure it's exactly 0
        currentState = TimerState.Completed;
        stopTickOperations();
      }
    }
  };

  /**
   * Capability: Sets up the initial state of the timer based on the provided configuration.
   * This method should be called once when the engine is created or when a full reset is needed.
   */
  const initialize = () => {
    stopTickOperations(); // Ensure no previous timer is running
    currentMode = TimerMode.Work;
    currentState = TimerState.Idle;
    // Re-initialize config in case the initialConfig object was mutated externally
    config = TimerConfigEntity(initialConfig);
    remainingTime = config.workDuration;
  };

  /**
   * Capability: Initiates the countdown for the current timer mode.
   * The timer will start only if it's in an Idle or Paused state.
   */
  const startTimer = () => {
    if (currentState === TimerState.Idle || currentState === TimerState.Paused) {
      currentState = TimerState.Running;
      // Clear any existing interval before setting a new one to prevent duplicates.
      stopTickOperations();
      // Trigger a periodic tick operation every 1 second.
      timerIntervalId = setInterval(tick, 1000);
    } else if (currentState === TimerState.Completed) {
      // As per constraints, no action if the timer is completed.
      // User input (reset or mode selection) is required to exit this state.
    }
  };

  /**
   * Capability: Suspends the countdown of the current timer mode.
   * The timer will pause only if it's currently running.
   */
  const pauseTimer = () => {
    if (currentState === TimerState.Running) {
      currentState = TimerState.Paused;
      stopTickOperations(); // Stop any active periodic tick operations.
    }
  };

  /**
   * Capability: Resets the current timer mode to its initial duration and Idle state.
   * This stops the timer and restores the time for the currently selected mode.
   */
  const resetTimer = () => {
    stopTickOperations(); // Stop any active periodic tick operations.
    currentState = TimerState.Idle;

    // Set remaining time based on the current mode's duration from the configuration.
    if (currentMode === TimerMode.Work) {
      remainingTime = config.workDuration;
    } else if (currentMode === TimerMode.ShortBreak) {
      remainingTime = config.shortBreakDuration;
    } else if (currentMode === TimerMode.LongBreak) {
      remainingTime = config.longBreakDuration;
    }
  };

  /**
   * Capability: Changes the active timer mode and resets the timer to the new mode's initial duration.
   *
   * @param {TimerMode} mode - The new mode to switch to (Work, ShortBreak, or LongBreak).
   */
  const selectMode = (mode) => {
    stopTickOperations(); // Stop any active periodic tick operations.
    currentMode = mode;
    currentState = TimerState.Idle;

    // Set remaining time based on the newly selected mode's duration.
    if (mode === TimerMode.Work) {
      remainingTime = config.workDuration;
    } else if (mode === TimerMode.ShortBreak) {
      remainingTime = config.shortBreakDuration;
    } else if (mode === TimerMode.LongBreak) {
      remainingTime = config.longBreakDuration;
    }
  };

  // Expose getters for the current state, as implied by "Devono esporre solo stato e funzioni"
  // and necessary for any consumer to observe the timer's status.
  const getCurrentMode = () => currentMode;
  const getCurrentState = () => currentState;
  const getRemainingTime = () => remainingTime;
  // Return a copy of the config to prevent external mutation of the internal state.
  const getConfig = () => ({ ...config });

  // Initialize the timer immediately when the engine is created
  initialize();

  // Return an object containing all public capabilities and state getters.
  return {
    initialize,
    startTimer,
    pauseTimer,
    resetTimer,
    selectMode,
    // State getters
    getCurrentMode,
    getCurrentState,
    getRemainingTime,
    getConfig,
  };
};