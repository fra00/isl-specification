--- ROLE: system ---

You are an expert ISL Developer. You are part of a team building the project "Space Invaders Clone".

**YOUR TASK**:
Write the content for the file: **start-game-presentation.isl.md**

**CONTEXT**:
- **Role**: Presentation
- **Description**: Renders the initial start screen and the game over screen. It handles user interactions to start a new game or restart after a game over.
- **Dependencies**: ["game-logic.isl.md","game-domain.isl.md"]

**DEPENDENCY INTERFACES (Read-Only)**:

--- INTERFACE: game-logic.isl.md ---
## Component: GameLogic
### Role: Business Logic
**Signature**: (gameConfig: > **Reference**: `GameConfig` in `./game-domain.isl.md`)
### Capabilities
#### initializeGame
**Contract**: Prepares the initial game state, setting up default values and the first level's configuration.
- **Signature**: `(): GameState`
- **Flow**:
  1. Create a new `GameState` instance.
  2. Set `status` to `INITIAL`.
  3. Set `score` to `0`.
  4. Set `levelNumber` to `1`.
  5. Initialize `playerState` with default position, `GameConstants.playerLives` lives, and `lastShotTime` to `0`.
  6. Initialize `invadersState`, `playerBullets`, `invaderBullets`, `shieldStates` as empty arrays.
  7. Set `lastUpdateTime` to the current timestamp.
  8. Set `gameConfig` to the `gameConfig` provided during component instantiation.
  9. Load `currentLevelConfig` by finding the `LevelConfig` for `levelNumber = 1` from `gameConfig.levelConfigs`.
  10. Initialize `playerActionFlags` with `moveLeft: false`, `moveRight: false`, `isShooting: false`.
  11. Set `invaderDirection` to `1` (initial movement to the right).
  12. Initialize `invaderMovementTimer`, `invaderDescentTimer`, `invaderShotTimer`, `playerShotCooldownTimer` to `0`.
- **Side Effects**: None directly, returns a new `GameState` object.
- **âœ… Acceptance Criteria**:
  - The returned `GameState` MUST have `status` set to `INITIAL`.
  - `score` MUST be `0`, and `levelNumber` MUST be `1`.
  - `playerState` MUST be initialized with full lives.
  - Entity arrays (`invadersState`, `playerBullets`, `invaderBullets`, `shieldStates`) MUST be empty.
  - `currentLevelConfig` MUST correspond to level 1.
**Signature**: `(): GameState`
- **Flow**:
  1. Create a new `GameState` instance.
  2. Set `status` to `INITIAL`.
  3. Set `score` to `0`.
  4. Set `levelNumber` to `1`.
  5. Initialize `playerState` with default position, `GameConstants.playerLives` lives, and `lastShotTime` to `0`.
  6. Initialize `invadersState`, `playerBullets`, `invaderBullets`, `shieldStates` as empty arrays.
  7. Set `lastUpdateTime` to the current timestamp.
  8. Set `gameConfig` to the `gameConfig` provided during component instantiation.
  9. Load `currentLevelConfig` by finding the `LevelConfig` for `levelNumber = 1` from `gameConfig.levelConfigs`.
  10. Initialize `playerActionFlags` with `moveLeft: false`, `moveRight: false`, `isShooting: false`.
  11. Set `invaderDirection` to `1` (initial movement to the right).
  12. Initialize `invaderMovementTimer`, `invaderDescentTimer`, `invaderShotTimer`, `playerShotCooldownTimer` to `0`.
- **Side Effects**: None directly, returns a new `GameState` object.
- **âœ… Acceptance Criteria**:
  - The returned `GameState` MUST have `status` set to `INITIAL`.
  - `score` MUST be `0`, and `levelNumber` MUST be `1`.
  - `playerState` MUST be initialized with full lives.
  - Entity arrays (`invadersState`, `playerBullets`, `invaderBullets`, `shieldStates`) MUST be empty.
  - `currentLevelConfig` MUST correspond to level 1.

#### startGame
**Contract**: Transitions the game from `INITIAL` to `PLAYING` and sets up the first level's entities.
- **Signature**: `(initialState: GameState): GameState`
- **Flow**:
  1. Create a copy of `initialState`.
  2. IF `initialState.status` is NOT `INITIAL`, THEN return the copied state unchanged.
  3. Set `status` to `PLAYING`.
  4. Reset `score` to `0`.
  5. Reset `levelNumber` to `1`.
  6. Reset `playerState` to its initial position, `GameConstants.playerLives` lives, and `lastShotTime` to `0`.
  7. Generate `invadersState` based on `currentLevelConfig` (rows, columns, initial positions).
  8. Generate `shieldStates` based on `gameConfig` (number of shields, segments per shield, positions).
  9. Clear `playerBullets` and `invaderBullets`.
  10. Reset `invaderDirection` to `1`.
  11. Reset `invaderMovementTimer` to `0`.
  12. Reset `invaderDescentTimer` to `0`.
  13. Reset `invaderShotTimer` to `0`.
  14. Reset `playerShotCooldownTimer` to `0`.
  15. Set `lastUpdateTime` to the current timestamp.
  16. Return the updated `GameState`.
- **Side Effects**: Modifies the `GameState` to reflect the start of a new game.
- **âœ… Acceptance Criteria**:
  - The returned `GameState.status` MUST be `PLAYING`.
  - Player, invaders, and shields MUST be initialized and positioned correctly.
  - Score and lives MUST be reset to starting values.
**Signature**: `(initialState: GameState): GameState`
- **Flow**:
  1. Create a copy of `initialState`.
  2. IF `initialState.status` is NOT `INITIAL`, THEN return the copied state unchanged.
  3. Set `status` to `PLAYING`.
  4. Reset `score` to `0`.
  5. Reset `levelNumber` to `1`.
  6. Reset `playerState` to its initial position, `GameConstants.playerLives` lives, and `lastShotTime` to `0`.
  7. Generate `invadersState` based on `currentLevelConfig` (rows, columns, initial positions).
  8. Generate `shieldStates` based on `gameConfig` (number of shields, segments per shield, positions).
  9. Clear `playerBullets` and `invaderBullets`.
  10. Reset `invaderDirection` to `1`.
  11. Reset `invaderMovementTimer` to `0`.
  12. Reset `invaderDescentTimer` to `0`.
  13. Reset `invaderShotTimer` to `0`.
  14. Reset `playerShotCooldownTimer` to `0`.
  15. Set `lastUpdateTime` to the current timestamp.
  16. Return the updated `GameState`.
- **Side Effects**: Modifies the `GameState` to reflect the start of a new game.
- **âœ… Acceptance Criteria**:
  - The returned `GameState.status` MUST be `PLAYING`.
  - Player, invaders, and shields MUST be initialized and positioned correctly.
  - Score and lives MUST be reset to starting values.

#### processPlayerInput
**Contract**: Updates the player's action flags within the game state based on discrete player input events (key presses/releases).
- **Signature**: `(currentState: GameState, action: ` > **Reference**: `PlayerActionEnum` in `./game-domain.isl.md`, `isPressed: boolean` `): GameState`
- **Flow**:
  1. Create a copy of `currentState`.
  2. IF `action` is `MOVE_LEFT`:
     THEN set `playerActionFlags.moveLeft` to `isPressed`.
  3. ELSE IF `action` is `MOVE_RIGHT`:
     THEN set `playerActionFlags.moveRight` to `isPressed`.
  4. ELSE IF `action` is `SHOOT`:
     THEN set `playerActionFlags.isShooting` to `isPressed`.
  5. Return the updated `GameState`.
- **Side Effects**: Updates `playerActionFlags` within the `GameState`.
- **âœ… Acceptance Criteria**:
  - The corresponding `playerActionFlags` in the returned `GameState` MUST be updated based on the `action` and `isPressed` value.
**Signature**: `(currentState: GameState, action: ` > **Reference**: `PlayerActionEnum` in `./game-domain.isl.md`, `isPressed: boolean` `): GameState`
- **Flow**:
  1. Create a copy of `currentState`.
  2. IF `action` is `MOVE_LEFT`:
     THEN set `playerActionFlags.moveLeft` to `isPressed`.
  3. ELSE IF `action` is `MOVE_RIGHT`:
     THEN set `playerActionFlags.moveRight` to `isPressed`.
  4. ELSE IF `action` is `SHOOT`:
     THEN set `playerActionFlags.isShooting` to `isPressed`.
  5. Return the updated `GameState`.
- **Side Effects**: Updates `playerActionFlags` within the `GameState`.
- **âœ… Acceptance Criteria**:
  - The corresponding `playerActionFlags` in the returned `GameState` MUST be updated based on the `action` and `isPressed` value.

#### updateGame
**Contract**: Advances the game state by one frame, handling movement, shooting, collisions, and game progression. This is the core of the game loop.
- **Signature**: `(currentState: GameState, currentTime: number): GameState`
- **Flow**:
  1. Create a copy of `currentState`.
  2. IF `currentState.status` is NOT `PLAYING`, THEN return the copied state unchanged.
  3. Calculate `deltaTime = currentTime - currentState.lastUpdateTime` (in milliseconds).
  4. Update `lastUpdateTime` to `currentTime`.
  5. Decrement `playerShotCooldownTimer` by `deltaTime`.
  6. Decrement `invaderMovementTimer` by `deltaTime`.
  7. Decrement `invaderDescentTimer` by `deltaTime`.
  8. Decrement `invaderShotTimer` by `deltaTime`.

  **Player Movement**:
  1. IF `playerActionFlags.moveLeft` is `true`:
     THEN move `playerState.position.x` left by `playerState.speed * deltaTime / 1000 (px)`.
  2. IF `playerActionFlags.moveRight` is `true`:
     THEN move `playerState.position.x` right by `playerState.speed * deltaTime / 1000 (px)`.
  3. Clamp `playerState.position.x` within `0` and `gameConfig.canvasWidth - playerState.size.width`.

  **Player Shooting**:
  1. IF `playerActionFlags.isShooting` is `true` AND `playerShotCooldownTimer` is `<= 0`:
     THEN create a new player bullet at `playerState.position` (adjusted to be centered and above player) and add it to `playerBullets`.
     THEN set `playerShotCooldownTimer` to `gameConfig.playerBulletCooldown`.

  **Invader Movement**:
  1. IF `invaderMovementTimer` is `<= 0`:
     a. Calculate invader horizontal speed based on `currentLevelConfig.invaderSpeedMultiplier` and `GameConstants.invaderBaseSpeed`.
     b. Move all `invadersState` horizontally by `invaderSpeed * invaderDirection * (GameConstants.invaderMovementInterval / 1000) (px)`.
     c. Reset `invaderMovementTimer` based on `GameConstants.invaderMovementInterval`.
     d. Check if any invader has reached the canvas edge:
        IF an invader hits the left edge (`position.x <= 0`) OR an invader hits the right edge (`position.x + size.width >= gameConfig.canvasWidth`):
           THEN reverse `invaderDirection` (`invaderDirection = -invaderDirection`).
           THEN move all invaders down by `GameConstants.invaderDescentAmount (px)`.
           THEN set `invaderDescentTimer` to `GameConstants.invaderDescentInterval`.
           THEN check for game over if any invader's `position.y + size.height` is `>= GameConstants.playerYPosition`.

  **Invader Shooting**:
  1. IF `invaderShotTimer` is `<= 0`:
     a. Select a random invader from the bottom row of each column (if available).
     b. IF an invader is selected:
        THEN create a new invader bullet at the invader's position (adjusted to be centered and below invader) and add it to `invaderBullets`.
     c. Reset `invaderShotTimer` based on `GameConstants.invaderShotBaseFrequency` multiplied by `currentLevelConfig.invaderShotFrequencyMultiplier`.

  **Bullet Movement**:
  1. Update positions of all `playerBullets` and `invaderBullets` based on their `speed` and `deltaTime`.
  2. Remove bullets that move off-screen (outside `0` to `gameConfig.canvasHeight`).

  **Collision Detection**:
  1. **Player Bullets vs. Invaders**:
     FOR EACH `playerBullet` in `playerBullets`:
       FOR EACH `invader` in `invadersState`:
         IF `playerBullet` collides with `invader` (AABB check):
           THEN remove `playerBullet`.
           THEN remove `invader`.
           THEN increment `score` by `GameConstants.invaderScoreValue`.
           THEN break (bullet can only hit one invader).
  2. **Player Bullets vs. Shields**:
     FOR EACH `playerBullet` in `playerBullets`:
       FOR EACH `shieldSegment` in `shieldStates`:
         IF `playerBullet` collides with `shieldSegment` (AABB check):
           THEN remove `playerBullet`.
           THEN decrement `shieldSegment.health`.
           THEN IF `shieldSegment.health` is `<= 0`, THEN remove `shieldSegment`.
           THEN break.
  3. **Invader Bullets vs. Player**:
     FOR EACH `invaderBullet` in `invaderBullets`:
       IF `invaderBullet` collides with `playerState` (AABB check):
         THEN remove `invaderBullet`.
         THEN decrement `playerState.lives`.
         THEN IF `playerState.lives` is `<= 0`, THEN set `status` to `GAME_OVER`.
         THEN reset `playerState.position` to its initial position.
         THEN clear all `playerBullets` and `invaderBullets`.
         THEN break.
  4. **Invader Bullets vs. Shields**:
     FOR EACH `invaderBullet` in `invaderBullets`:
       FOR EACH `shieldSegment` in `shieldStates`:
         IF `invaderBullet` collides with `shieldSegment` (AABB check):
           THEN remove `invaderBullet`.
           THEN decrement `shieldSegment.health`.
           THEN IF `shieldSegment.health` is `<= 0`, THEN remove `shieldSegment`.
           THEN break.

  **Game State Checks**:
  1. **Level Completion**:
     IF `invadersState` is empty:
       THEN IF `levelNumber` is `< gameConfig.maxLevels`:
         THEN call `loadNextLevel` with the current state to advance to the next level.
       THEN ELSE (`levelNumber` is `gameConfig.maxLevels`):
         THEN set `status` to `GAME_WON`.
  2. **Game Over (Invaders reached bottom)**:
     IF any `invader`'s `position.y + size.height` is `>= GameConstants.playerYPosition`:
       THEN set `status` to `GAME_OVER`.
  3. **Game Over (Player out of lives)**:
     IF `playerState.lives` is `<= 0`:
       THEN set `status` to `GAME_OVER`.

  9. Return the updated `GameState`.
- **Side Effects**: Modifies `GameState` significantly, including entity positions, health, scores, lives, and game status.
- **ðŸ’¡ Implementation Hint**: Collision detection can be optimized using spatial partitioning if performance becomes an issue with many entities.
- **ðŸš¨ Constraint**: `deltaTime` MUST be non-negative.
- **âœ… Acceptance Criteria**:
  - Player, invader, and bullet positions MUST be updated correctly based on `deltaTime`.
  - Collisions MUST be detected accurately, resulting in appropriate score updates, entity removals, and life deductions.
  - Game status MUST transition to `GAME_OVER` or `GAME_WON` upon respective conditions.
  - `playerShotCooldownTimer` and `invaderShotTimer` MUST correctly regulate shooting frequency.
  - Invaders MUST move horizontally, descend, and reverse direction correctly.
  - Level progression MUST occur when all invaders are destroyed, up to `maxLevels`.
**Signature**: `(currentState: GameState, currentTime: number): GameState`
- **Flow**:
  1. Create a copy of `currentState`.
  2. IF `currentState.status` is NOT `PLAYING`, THEN return the copied state unchanged.
  3. Calculate `deltaTime = currentTime - currentState.lastUpdateTime` (in milliseconds).
  4. Update `lastUpdateTime` to `currentTime`.
  5. Decrement `playerShotCooldownTimer` by `deltaTime`.
  6. Decrement `invaderMovementTimer` by `deltaTime`.
  7. Decrement `invaderDescentTimer` by `deltaTime`.
  8. Decrement `invaderShotTimer` by `deltaTime`.

  **Player Movement**:
  1. IF `playerActionFlags.moveLeft` is `true`:
     THEN move `playerState.position.x` left by `playerState.speed * deltaTime / 1000 (px)`.
  2. IF `playerActionFlags.moveRight` is `true`:
     THEN move `playerState.position.x` right by `playerState.speed * deltaTime / 1000 (px)`.
  3. Clamp `playerState.position.x` within `0` and `gameConfig.canvasWidth - playerState.size.width`.

  **Player Shooting**:
  1. IF `playerActionFlags.isShooting` is `true` AND `playerShotCooldownTimer` is `<= 0`:
     THEN create a new player bullet at `playerState.position` (adjusted to be centered and above player) and add it to `playerBullets`.
     THEN set `playerShotCooldownTimer` to `gameConfig.playerBulletCooldown`.

  **Invader Movement**:
  1. IF `invaderMovementTimer` is `<= 0`:
     a. Calculate invader horizontal speed based on `currentLevelConfig.invaderSpeedMultiplier` and `GameConstants.invaderBaseSpeed`.
     b. Move all `invadersState` horizontally by `invaderSpeed * invaderDirection * (GameConstants.invaderMovementInterval / 1000) (px)`.
     c. Reset `invaderMovementTimer` based on `GameConstants.invaderMovementInterval`.
     d. Check if any invader has reached the canvas edge:
        IF an invader hits the left edge (`position.x <= 0`) OR an invader hits the right edge (`position.x + size.width >= gameConfig.canvasWidth`):
           THEN reverse `invaderDirection` (`invaderDirection = -invaderDirection`).
           THEN move all invaders down by `GameConstants.invaderDescentAmount (px)`.
           THEN set `invaderDescentTimer` to `GameConstants.invaderDescentInterval`.
           THEN check for game over if any invader's `position.y + size.height` is `>= GameConstants.playerYPosition`.

  **Invader Shooting**:
  1. IF `invaderShotTimer` is `<= 0`:
     a. Select a random invader from the bottom row of each column (if available).
     b. IF an invader is selected:
        THEN create a new invader bullet at the invader's position (adjusted to be centered and below invader) and add it to `invaderBullets`.
     c. Reset `invaderShotTimer` based on `GameConstants.invaderShotBaseFrequency` multiplied by `currentLevelConfig.invaderShotFrequencyMultiplier`.

  **Bullet Movement**:
  1. Update positions of all `playerBullets` and `invaderBullets` based on their `speed` and `deltaTime`.
  2. Remove bullets that move off-screen (outside `0` to `gameConfig.canvasHeight`).

  **Collision Detection**:
  1. **Player Bullets vs. Invaders**:
     FOR EACH `playerBullet` in `playerBullets`:
       FOR EACH `invader` in `invadersState`:
         IF `playerBullet` collides with `invader` (AABB check):
           THEN remove `playerBullet`.
           THEN remove `invader`.
           THEN increment `score` by `GameConstants.invaderScoreValue`.
           THEN break (bullet can only hit one invader).
  2. **Player Bullets vs. Shields**:
     FOR EACH `playerBullet` in `playerBullets`:
       FOR EACH `shieldSegment` in `shieldStates`:
         IF `playerBullet` collides with `shieldSegment` (AABB check):
           THEN remove `playerBullet`.
           THEN decrement `shieldSegment.health`.
           THEN IF `shieldSegment.health` is `<= 0`, THEN remove `shieldSegment`.
           THEN break.
  3. **Invader Bullets vs. Player**:
     FOR EACH `invaderBullet` in `invaderBullets`:
       IF `invaderBullet` collides with `playerState` (AABB check):
         THEN remove `invaderBullet`.
         THEN decrement `playerState.lives`.
         THEN IF `playerState.lives` is `<= 0`, THEN set `status` to `GAME_OVER`.
         THEN reset `playerState.position` to its initial position.
         THEN clear all `playerBullets` and `invaderBullets`.
         THEN break.
  4. **Invader Bullets vs. Shields**:
     FOR EACH `invaderBullet` in `invaderBullets`:
       FOR EACH `shieldSegment` in `shieldStates`:
         IF `invaderBullet` collides with `shieldSegment` (AABB check):
           THEN remove `invaderBullet`.
           THEN decrement `shieldSegment.health`.
           THEN IF `shieldSegment.health` is `<= 0`, THEN remove `shieldSegment`.
           THEN break.

  **Game State Checks**:
  1. **Level Completion**:
     IF `invadersState` is empty:
       THEN IF `levelNumber` is `< gameConfig.maxLevels`:
         THEN call `loadNextLevel` with the current state to advance to the next level.
       THEN ELSE (`levelNumber` is `gameConfig.maxLevels`):
         THEN set `status` to `GAME_WON`.
  2. **Game Over (Invaders reached bottom)**:
     IF any `invader`'s `position.y + size.height` is `>= GameConstants.playerYPosition`:
       THEN set `status` to `GAME_OVER`.
  3. **Game Over (Player out of lives)**:
     IF `playerState.lives` is `<= 0`:
       THEN set `status` to `GAME_OVER`.

  9. Return the updated `GameState`.
- **Side Effects**: Modifies `GameState` significantly, including entity positions, health, scores, lives, and game status.
- **ðŸ’¡ Implementation Hint**: Collision detection can be optimized using spatial partitioning if performance becomes an issue with many entities.
- **ðŸš¨ Constraint**: `deltaTime` MUST be non-negative.
- **âœ… Acceptance Criteria**:
  - Player, invader, and bullet positions MUST be updated correctly based on `deltaTime`.
  - Collisions MUST be detected accurately, resulting in appropriate score updates, entity removals, and life deductions.
  - Game status MUST transition to `GAME_OVER` or `GAME_WON` upon respective conditions.
  - `playerShotCooldownTimer` and `invaderShotTimer` MUST correctly regulate shooting frequency.
  - Invaders MUST move horizontally, descend, and reverse direction correctly.
  - Level progression MUST occur when all invaders are destroyed, up to `maxLevels`.

#### loadNextLevel
**Contract**: Prepares the game for the next level, incrementing the level number, resetting entities, and applying new level configurations.
- **Signature**: `(currentState: GameState): GameState`
- **Flow**:
  1. Create a copy of `currentState`.
  2. Increment `levelNumber` by `1`.
  3. IF `levelNumber` is `> gameConfig.maxLevels`:
     THEN set `status` to `GAME_WON` and return the copied state.
  4. Load `currentLevelConfig` by finding the `LevelConfig` for the new `levelNumber` from `gameConfig.levelConfigs`.
  5. Reset `playerState.position` to its initial position.
  6. Generate new `invadersState` based on the new `currentLevelConfig`.
  7. Regenerate `shieldStates` to full health based on `gameConfig`.
  8. Clear `playerBullets` and `invaderBullets`.
  9. Reset `invaderDirection` to `1`.
  10. Reset `invaderMovementTimer` to `0`.
  11. Reset `invaderDescentTimer` to `0`.
  12. Reset `invaderShotTimer` to `0`.
  13. Reset `playerShotCooldownTimer` to `0`.
  14. Set `lastUpdateTime` to the current timestamp.
  15. Return the updated `GameState`.
- **Side Effects**: Resets game entities and updates `levelNumber` and `currentLevelConfig`.
- **âœ… Acceptance Criteria**:
  - `levelNumber` MUST be incremented (unless `maxLevels` is reached).
  - New invaders and fully repaired shields MUST be generated.
  - Bullets MUST be cleared.
  - `currentLevelConfig` MUST reflect the new level's configuration.
  - If `maxLevels` is reached, `status` MUST transition to `GAME_WON`.
**Signature**: `(currentState: GameState): GameState`
- **Flow**:
  1. Create a copy of `currentState`.
  2. Increment `levelNumber` by `1`.
  3. IF `levelNumber` is `> gameConfig.maxLevels`:
     THEN set `status` to `GAME_WON` and return the copied state.
  4. Load `currentLevelConfig` by finding the `LevelConfig` for the new `levelNumber` from `gameConfig.levelConfigs`.
  5. Reset `playerState.position` to its initial position.
  6. Generate new `invadersState` based on the new `currentLevelConfig`.
  7. Regenerate `shieldStates` to full health based on `gameConfig`.
  8. Clear `playerBullets` and `invaderBullets`.
  9. Reset `invaderDirection` to `1`.
  10. Reset `invaderMovementTimer` to `0`.
  11. Reset `invaderDescentTimer` to `0`.
  12. Reset `invaderShotTimer` to `0`.
  13. Reset `playerShotCooldownTimer` to `0`.
  14. Set `lastUpdateTime` to the current timestamp.
  15. Return the updated `GameState`.
- **Side Effects**: Resets game entities and updates `levelNumber` and `currentLevelConfig`.
- **âœ… Acceptance Criteria**:
  - `levelNumber` MUST be incremented (unless `maxLevels` is reached).
  - New invaders and fully repaired shields MUST be generated.
  - Bullets MUST be cleared.
  - `currentLevelConfig` MUST reflect the new level's configuration.
  - If `maxLevels` is reached, `status` MUST transition to `GAME_WON`.

#### resetGame
**Contract**: Resets the entire game state to its initial `INITIAL` status, ready for a new game start.
- **Signature**: `(currentState: GameState): GameState`
- **Flow**:
  1. Create a copy of `currentState`.
  2. Set `status` to `INITIAL`.
  3. Reset `score` to `0`.
  4. Reset `levelNumber` to `1`.
  5. Reset `playerState` to its initial position, `GameConstants.playerLives` lives, and `lastShotTime` to `0`.
  6. Clear `invadersState`, `playerBullets`, `invaderBullets`, `shieldStates`.
  7. Reset `playerActionFlags` to all `false`.
  8. Reset `invaderDirection` to `1`.
  9. Reset `invaderMovementTimer`, `invaderDescentTimer`, `invaderShotTimer`, `playerShotCooldownTimer` to `0`.
  10. Set `lastUpdateTime` to the current timestamp.
  11. Load `currentLevelConfig` for `levelNumber = 1`.
  12. Return the updated `GameState`.
- **Side Effects**: Resets the `GameState` to its default starting values.
- **âœ… Acceptance Criteria**:
  - The returned `GameState.status` MUST be `INITIAL`.
  - All dynamic game elements (score, lives, entities) MUST be reset to their default starting values.
**Signature**: `(currentState: GameState): GameState`
- **Flow**:
  1. Create a copy of `currentState`.
  2. Set `status` to `INITIAL`.
  3. Reset `score` to `0`.
  4. Reset `levelNumber` to `1`.
  5. Reset `playerState` to its initial position, `GameConstants.playerLives` lives, and `lastShotTime` to `0`.
  6. Clear `invadersState`, `playerBullets`, `invaderBullets`, `shieldStates`.
  7. Reset `playerActionFlags` to all `false`.
  8. Reset `invaderDirection` to `1`.
  9. Reset `invaderMovementTimer`, `invaderDescentTimer`, `invaderShotTimer`, `playerShotCooldownTimer` to `0`.
  10. Set `lastUpdateTime` to the current timestamp.
  11. Load `currentLevelConfig` for `levelNumber = 1`.
  12. Return the updated `GameState`.
- **Side Effects**: Resets the `GameState` to its default starting values.
- **âœ… Acceptance Criteria**:
  - The returned `GameState.status` MUST be `INITIAL`.
  - All dynamic game elements (score, lives, entities) MUST be reset to their default starting values.

### ðŸš¨ Global Constraints
- All entity positions and sizes MUST remain within the `gameConfig.canvasWidth` and `gameConfig.canvasHeight` boundaries where appropriate.
- `deltaTime` passed to `updateGame` MUST be non-negative.
- The `levelNumber` MUST NOT exceed `gameConfig.maxLevels`.
- `playerState.lives` MUST NOT be negative.

--- INTERFACE: game-domain.isl.md ---
## Domain Concepts


### ðŸ“¦ Content/Structure


### ðŸ’¡ Global Hints
- All coordinate systems assume (0,0) is the top-left corner of the game canvas.
- `id` fields for entities like `InvaderState` and `BulletState` are crucial for efficient updates and rendering in presentation layers.
- Multipliers in `LevelConfig` allow for progressive difficulty scaling across levels.
- `PlayerActionEnum` provides a clear, semantic way to represent player input, decoupling it from specific key presses.

### ðŸš¨ Global Constraints
- All `Position` and `Size` values MUST be non-negative.
- `speed` values MUST be non-negative.
- `health` values for `ShieldSegmentState` MUST be non-negative.
- `lastShotTime` MUST be a valid timestamp (milliseconds since epoch).
- `levelNumber` MUST be a positive integer.
- `invaderRows` and `invaderCols` MUST be positive integers.
- All multiplier values MUST be positive.
- `playerBulletCooldown` and `invaderShotBaseFrequency` MUST be non-negative.
- `maxLevels` MUST be at least 10, as per the original requirements.

### Acceptance Criteria
- The `GameStatusEnum` accurately represents all major game states.
- All game entities (`Player`, `Invader`, `Bullet`, `Shield Segment`) have their essential properties defined in corresponding data structures.
- `PlayerActionEnum` correctly enumerates all fundamental player input intentions.
- `LevelConfig` provides sufficient parameters to customize level difficulty and layout.
- `GameConfig` and `GameConstants` encapsulate all global and fixed numerical parameters with appropriate units.
- All defined types are clear, unambiguous, and directly support the game's core mechanics.

### ðŸ§ª Test Scenarios
- **Scenario**: Verify `GameStatusEnum` transitions.
  - **Given**: A game is in `INITIAL` state.
  - **When**: Player starts the game.
  - **Then**: Game status transitions to `PLAYING`.
  - **When**: Player loses all lives.
  - **Then**: Game status transitions to `GAME_OVER`.
- **Scenario**: Verify `PlayerState` properties.
  - **Given**: A `PlayerState` instance.
  - **Then**: It MUST contain `position`, `size`, `speed`, `lives`, `isShooting`, and `lastShotTime` with correct types and units.
- **Scenario**: Verify `LevelConfig` scaling.
  - **Given**: `LevelConfig` for `levelNumber = 1` and `levelNumber = 5`.
  - **Then**: `invaderSpeedMultiplier` for `levelNumber = 5` SHOULD be greater than or equal to `levelNumber = 1`.
  - **Then**: `invaderShotFrequencyMultiplier` for `levelNumber = 5` SHOULD be less than or equal to `levelNumber = 1` (indicating more frequent shots).
- **Scenario**: Validate `GameConfig` constraints.
  - **Given**: A `GameConfig` instance.
  - **Then**: `maxLevels` MUST be `>= 10`.
  - **Then**: `playerBulletCooldown` MUST be `>= 0 (ms)`.
  - **Then**: `canvasWidth` and `canvasHeight` MUST be positive `(px)`.
- **Scenario**: Verify `PlayerActionEnum` values.
  - **Given**: The `PlayerActionEnum` definition.
  - **Then**: It MUST include `MOVE_LEFT`, `MOVE_RIGHT`, and `SHOOT` as distinct actions.

## Component: GameDomain
### Role: Domain




## Canonical Rules (NORMATIVE)

### Rule 1: Semantic Markers
Sections with emoji are **NORMATIVE** (must implement exactly):
- âš¡ Capabilities/Methods
- ðŸš¨ Constraints
- âœ… Acceptance Criteria
- ðŸ§ª Test Scenarios

Sections without normative emoji are **INFORMATIVE** (guidance only):
- ðŸ“ Appearance/Interface
- ðŸ“¦ Content/Structure
- ðŸ’¡ Implementation Hints

### Rule 4: ISL Boundary (Critical)
ISL defines **intent and behavior**, NOT implementation.
**MUST**:
- Define observable behavior
- Describe what system does
- Express logic as intent/rules/outcomes
- Remain implementation-agnostic
**MUST NOT**:
- Describe step-by-step algorithms
- Be written as pseudocode
- Act as Technical Design Document
- Contain low-level control flow tied to syntax

**Flow Syntax Constraints**:
Flows MUST describe intent/operations using natural language, NOT implementation code or pseudocode.
â›” FORBIDDEN:
- The word "Call" or "Invoke" targeting a specific method (e.g., "Call renderScore", "Invoke GameCanvas.render").
- Pseudocode syntax (e.g., "execute(param)", "object.method()").
âœ… REQUIRED:
- Use descriptive verbs describing the *intent* (e.g., "Display the score", "Calculate the total", "Update the state", "GameScreen updates content", "Component updates layout").
- For component interactions, use: "Trigger", "Dispatch", "Request", or "Pass data to" (e.g. "Trigger GameEngine update", NOT "Call GameEngine.update").


**Supported Control Structures**:
- `IF...THEN...ELSE`
- `FOR EACH...IN`
- `WHILE condition`
- `TRY...CATCH`
- `BRANCH: [conditions]`

### Rule 5: Role Separation
- **Presentation**: MUST define visual appearance. MUST NOT implement business logic.
- **Backend**: MUST define API contracts. MUST NOT define visual properties.

### Rule 6: Content Semantics (Structural Composition)
The `ðŸ“¦ Content` section defines the **Structural Composition** of the component.
- **For Leaf Components**: Describes visual elements (buttons, text, inputs).
- **For Container Components**: Lists the **Child Components** included in this view.
  - **Usage**: Use this section to declare *what* is rendered (e.g., "Contains `Header` and `Footer`"), NOT the `Flow` section.
  - **Layout**: Describe how children are arranged (e.g., "Sidebar on left, Grid on right").

### Rule 7: Entry Point Autonomy
The Root/Entry Point component (usually `Main`) MUST be **Autonomous**.
- **Signature**: MUST be Void (no arguments), unless explicitly required by requirements.
- It is responsible for instantiating dependencies (Composition Root), not receiving them.

### Rule 8: Abstraction Level (Input & Events)
ISL describes **Intent**, not Syntax.
- **Input**: Describe physical actions or intents, NOT specific event properties.
  - âœ… "On Physical Key 'Space' Press", "When User clicks Submit"
  - â›” "IF event.key === ' '", "onClick(e)"
- **Implementation Agnostic**: Do not mention specific browser/runtime APIs (e.g., `window.addEventListener`) unless wrapping them in a Capability.

### Rule 9: Units & Precision
All numeric values in Domain or Logic MUST specify **Units of Measurement**.
- âœ… `speed: 300 (px/s)`, `timeout: 500 (ms)`, `angle: 90 (deg)`
- â›” `speed: 5`, `timeout: 500`

### Rule 10: Real-Time & Continuous Logic
For systems involving time (Games, Simulations, Animations):
- **Separation**: Distinguish between **Discrete Input** (Events) and **Continuous Logic** (Update Loop).
- **Input**: Should typically update State Flags (e.g., `isMovingLeft = true`).
- **Update Loop**: Logic involving movement or physics MUST be described as a function of **Time** (DeltaTime), not just discrete steps.

## Document Structure
   - ## Domain Concepts (Optional)
   - ## Component: [Name]
     - ### Role: [Presentation | Backend | Business Logic]
     - **Signature**: [Input Props / Constructor Args]
     - ### ðŸ“ Appearance (Only for Presentation)
     - ### ðŸ“¦ Content (Only for Presentation)
     - ### âš¡ Capabilities
       - #### [capabilityName]
         - **Contract**: [Description]
         - **Signature**: Input/Output
         - **Trigger**: [Event]
         - **Flow** (if logic is complex)
         - **Side Effects**
         - **Cleanup**
         - **ðŸ’¡ Implementation Hint**
         - **ðŸš¨ Constraint**
         - **âœ… Acceptance Criteria**
         - **ðŸ§ª Test Scenarios**
     - ### ðŸ’¡ Global Hints
     - ### ðŸš¨ Global Constraints
     - ### âœ… Acceptance Criteria
     - ### ðŸ§ª Test Scenarios

## RFC 2119 Keywords
- **MUST**: Absolute requirement
- **MUST NOT**: Absolute prohibition
- **SHOULD**: Strong preference


**INTEGRATION RULES**:
1. You are aware of the full system plan (see below), but your focus is ONLY on **start-game-presentation.isl.md**.
2. If you need to refer to concepts in your dependencies, use the ISL reference syntax:
   `> **Reference**: [Concept] in ./dependency-filename.isl.md`
3. Do NOT generate code for other files.
4. **MISSING DEPENDENCIES**:
   If a required capability is missing in a dependency (visible in DEPENDENCY INTERFACES), do NOT hallucinate it.
   Instead, output a request to update the dependency using this format:
   #[DEPENDENCY_UPDATE_REQUEST]
   {
     "targetFilename": "filename.isl.md",
     "description": "Add capability 'X' to handle Y."
   }
   #[DEPENDENCY_UPDATE_REQUEST-END]
5. **MISSING DEPENDENCY FILE**:
   If you need to access types or capabilities from a file that is NOT in your dependencies list (e.g. Domain Enums), request it:
   #[MISSING_DEPENDENCY_FILE]
   {
     "filename": "domain.isl.md",
     "reason": "Need access to GameStatusEnum"
   }
   #[MISSING_DEPENDENCY_FILE-END]

**OUTPUT RULES**:
- Do NOT output the Project Name or Metadata Header.
- **MANDATORY**: You MUST start the file content with a list of references for ALL dependencies listed in your 'Dependencies' context:
  > **Reference**: Concepts/Capabilities in `./game-logic.isl.md`
  > **Reference**: Concepts/Capabilities in `./game-domain.isl.md`
  (Adjust the description text as appropriate for the dependency role).
- Return ONLY the markdown content for start-game-presentation.isl.md.


--- ROLE: user ---

**ARCHITECT'S PLAN (Global Context)**:
- **game-domain.isl.md** [Domain]
  Description: Defines core data structures, enums, and constants for the Space Invaders game. This includes states for player, invaders, bullets, and level configurations.
  Dependencies: None

- **game-logic.isl.md** [Business Logic]
  Description: Manages the entire game state, including the game loop, collision detection, scoring, lives, and progression through multiple levels (at least 10).
  Dependencies: game-domain.isl.md

- **game-board-presentation.isl.md** [Presentation]
  Description: Renders the visual elements of the main game board, including the player ship, invader fleet, and all active bullets. It also captures user input for player actions.
  Dependencies: game-logic.isl.md, game-domain.isl.md

- **hud-presentation.isl.md** [Presentation]
  Description: Displays the Head-Up Display (HUD) elements such as the current score, remaining lives, and the current level number.
  Dependencies: game-logic.isl.md, game-domain.isl.md

- **start-game-presentation.isl.md** [Presentation]
  Description: Renders the initial start screen and the game over screen. It handles user interactions to start a new game or restart after a game over.
  Dependencies: game-logic.isl.md, game-domain.isl.md

- **main.isl.md** [Presentation]
  Description: The entry point of the Space Invaders application. It orchestrates the game by initializing the game logic, setting up the main game loop, and rendering various presentation components based on the current game state.
  Dependencies: game-logic.isl.md, game-board-presentation.isl.md, hud-presentation.isl.md, start-game-presentation.isl.md

**ORIGINAL REQUIREMENTS**:
"Progetta un clone per il gioco space invaders con ReacJs(javascript), deve essere molto simile e avere almeno 10 livelli"

