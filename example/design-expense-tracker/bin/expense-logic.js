/**
 * ðŸ›‘ DO NOT EDIT THIS FILE DIRECTLY
 * ----------------------------------
 * This file was generated by ISL Compiler.
 * Source: expense-logic.isl.md
 * Edit the ISL file instead.
 */

import { ExpenseCategoryType, ExpenseEntity } from "./domain";

// Internal state for expenses. This module acts as a singleton for expense management.
let expenses = [];

/**
 * Generates a unique identifier (UUID).
 * This uses the Web Crypto API, which is available in modern browser environments
 * and Node.js (v14.17.0+ for globalThis.crypto).
 * @returns {string} A unique UUID string.
 */
const generateUniqueId = () => crypto.randomUUID();

/**
 * Records a new expense into the system.
 *
 * @param {object} input - The expense details.
 * @param {number} input.amount - The monetary value of the expense. Must be greater than 0.
 * @param {string} input.description - A textual description of the expense.
 * @param {string} input.date - The date when the expense occurred (ISO-8601 format).
 * @param {string} input.category - The category to which the expense belongs, must be one of ExpenseCategoryType values.
 * @returns {object} The newly created expense entity.
 * @throws {Error} If any input constraint is violated.
 */
export function addExpense({ amount, description, date, category }) {
  // Constraints check
  if (amount <= 0) {
    throw new Error("Amount must be a positive number.");
  }

  const parsedDate = new Date(date);
  if (isNaN(parsedDate.getTime())) {
    throw new Error("Date must be a valid ISO-8601 formatted string.");
  }

  // Verify if the category is one of the predefined ExpenseCategoryType values
  if (!Object.values(ExpenseCategoryType).includes(category)) {
    throw new Error(`Invalid category: "${category}". Must be one of: ${Object.values(ExpenseCategoryType).join(', ')}.`);
  }

  // 1. Generate a unique id (UUID).
  const id = generateUniqueId();

  // 2. Create a new ExpenseEntity using the provided input and the generated id.
  const newExpense = ExpenseEntity({
    id,
    amount,
    description,
    date,
    category,
  });

  // 3. Add the new ExpenseEntity to the internal list of expenses.
  // We create a new array to ensure immutability of the internal state reference.
  expenses = [...expenses, newExpense];

  // 4. Return the created ExpenseEntity.
  return newExpense;
}

/**
 * Retrieves all recorded expenses, sorted by date in descending order (most recent first).
 *
 * @returns {Array<object>} A new array containing all expense entities, sorted.
 */
export function getExpenses() {
  // 1. Retrieve the current internal list of ExpenseEntity objects.
  // 2. Sort the list by the date property in descending order (most recent first).
  // Create a shallow copy before sorting to avoid mutating the internal 'expenses' array directly.
  return [...expenses].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

/**
 * Calculates the sum of all amounts from the recorded expenses.
 *
 * @returns {number} The total monetary value of all expenses.
 */
export function getTotalExpenses() {
  // 1. Retrieve the current internal list of ExpenseEntity objects.
  // 2. Initialize total to 0.
  let total = 0;

  // 3. FOR EACH expense IN the list:
  //    1. Add expense.amount to total.
  for (const expense of expenses) {
    total += expense.amount;
  }

  // 4. Return total.
  return total;
}