/**
 * ðŸ›‘ DO NOT EDIT THIS FILE DIRECTLY
 * ----------------------------------
 * This file was generated by ISL Compiler.
 * Source: customer-logic.isl.md
 * Edit the ISL file instead.
 */

import {
  CustomerId,
  Address,
  CustomerStatus,
  Customer,
  CustomerProfileUpdate,
} from './domain';

// In-memory data store (simulating a database for demonstration purposes)
// This array will be mutated by the logic functions to reflect changes.
let customersData = [
  Customer({
    id: CustomerId('cust-001'),
    firstName: 'Alice',
    lastName: 'Smith',
    email: 'alice.smith@example.com',
    phoneNumber: '111-222-3333',
    shippingAddress: Address({ street: '123 Main St', city: 'Anytown', state: 'CA', zipCode: '90210', country: 'USA' }),
    billingAddress: Address({ street: '123 Main St', city: 'Anytown', state: 'CA', zipCode: '90210', country: 'USA' }),
    status: CustomerStatus.ACTIVE,
    totalOrders: 5,
    totalSpent: 250.75,
    createdAt: new Date('2023-01-15T10:00:00Z'),
    updatedAt: new Date('2024-03-01T11:30:00Z'),
  }),
  Customer({
    id: CustomerId('cust-002'),
    firstName: 'Bob',
    lastName: 'Johnson',
    email: 'bob.j@example.com',
    phoneNumber: '444-555-6666',
    shippingAddress: Address({ street: '456 Oak Ave', city: 'Otherville', state: 'NY', zipCode: '10001', country: 'USA' }),
    billingAddress: Address({ street: '456 Oak Ave', city: 'Otherville', state: 'NY', zipCode: '10001', country: 'USA' }),
    status: CustomerStatus.INACTIVE,
    totalOrders: 2,
    totalSpent: 75.00,
    createdAt: new Date('2023-02-20T14:00:00Z'),
    updatedAt: new Date('2024-01-10T09:00:00Z'),
  }),
  Customer({
    id: CustomerId('cust-003'),
    firstName: 'Charlie',
    lastName: 'Brown',
    email: 'charlie.b@example.com',
    phoneNumber: '777-888-9999',
    shippingAddress: Address({ street: '789 Pine Ln', city: 'Smalltown', state: 'TX', zipCode: '73301', country: 'USA' }),
    billingAddress: Address({ street: '789 Pine Ln', city: 'Smalltown', state: 'TX', zipCode: '73301', country: 'USA' }),
    status: CustomerStatus.ACTIVE,
    totalOrders: 10,
    totalSpent: 1200.50,
    createdAt: new Date('2022-11-01T08:00:00Z'),
    updatedAt: new Date('2024-02-28T16:00:00Z'),
  }),
  Customer({
    id: CustomerId('cust-004'),
    firstName: 'Diana',
    lastName: 'Prince',
    email: 'diana.p@example.com',
    phoneNumber: '123-456-7890',
    shippingAddress: Address({ street: '1 Themyscira Way', city: 'Paradise Island', state: 'FL', zipCode: '33101', country: 'USA' }),
    billingAddress: Address({ street: '1 Themyscira Way', city: 'Paradise Island', state: 'FL', zipCode: '33101', country: 'USA' }),
    status: CustomerStatus.PENDING,
    totalOrders: 0,
    totalSpent: 0,
    createdAt: new Date('2024-03-10T10:00:00Z'),
    updatedAt: new Date('2024-03-10T10:00:00Z'),
  }),
];

/**
 * Retrieves a paginated list of customer profiles, optionally filtered.
 * @param {number} page - The current page number (1-indexed).
 * @param {number} pageSize - The number of customers per page.
 * @param {object} [filters={}] - Optional filters (status, searchQuery).
 * @returns {{customers: Array<ReturnType<typeof Customer>>, totalCount: number}}
 */
export function fetchCustomers(page, pageSize, filters = {}) {
  // 1. Request customer data from the underlying data store.
  let filteredCustomers = [...customersData];

  // 3. Apply any provided filters to the customer data.
  const { status, searchQuery } = filters;

  if (status != null) {
    filteredCustomers = filteredCustomers.filter(customer => customer.status === status);
  }

  if (searchQuery != null && searchQuery.trim() !== '') {
    const lowerCaseSearchQuery = searchQuery.toLowerCase();
    filteredCustomers = filteredCustomers.filter(customer =>
      customer.firstName.toLowerCase().includes(lowerCaseSearchQuery) ||
      customer.lastName.toLowerCase().includes(lowerCaseSearchQuery) ||
      customer.email.toLowerCase().includes(lowerCaseSearchQuery)
    );
  }

  // 4. Count the total number of customers matching the filters, ignoring pagination.
  const totalCount = filteredCustomers.length;

  // 2. Apply pagination based on `page` and `pageSize`.
  const startIndex = (page - 1) * pageSize;
  const paginatedCustomers = filteredCustomers.slice(startIndex, startIndex + pageSize);

  // 5. Return the list of `Customer` objects and the `totalCount`.
  return { customers: paginatedCustomers, totalCount };
}

/**
 * Retrieves a single customer's detailed profile by their unique identifier.
 * @param {string} customerId - The unique identifier of the customer.
 * @returns {ReturnType<typeof Customer>}
 * @throws {Error} If the customer is not found.
 */
export function fetchCustomerProfile(customerId) {
  // 1. Request a specific customer's data using the `customerId`.
  const customer = customersData.find(c => c.id === customerId);

  // 2. IF the customer is not found THEN indicate an error.
  if (customer == null) {
    throw new Error(`Customer with ID ${customerId} not found.`);
  }

  // 3. Return the `Customer` object.
  return customer;
}

/**
 * Updates an existing customer's information.
 * @param {string} customerId - The unique identifier of the customer to update.
 * @param {object} updates - An object containing the fields to update.
 * @returns {ReturnType<typeof Customer>}
 * @throws {Error} If the customer is not found.
 */
export function updateCustomerProfile(customerId, updates) {
  // 2. Locate the customer by `customerId`.
  const customerIndex = customersData.findIndex(c => c.id === customerId);

  // 3. IF the customer is not found THEN indicate an error.
  if (customerIndex === -1) {
    throw new Error(`Customer with ID ${customerId} not found.`);
  }

  const existingCustomer = customersData[customerIndex];

  // 1. Validate the `updates` data against the expected structure for a `Customer` profile.
  // Use CustomerProfileUpdate factory to filter and normalize updates, ensuring immutability for nested objects.
  const validatedUpdates = CustomerProfileUpdate(updates);

  // 4. Apply the `updates` to the customer's profile.
  // Create a new customer object to ensure immutability.
  const updatedCustomer = Customer({
    ...existingCustomer,
    ...validatedUpdates,
    updatedAt: new Date(), // Always update timestamp on modification
  });

  // 5. Persist the updated customer data in the data store.
  // Replace the old customer object with the new one immutably.
  customersData = [
    ...customersData.slice(0, customerIndex),
    updatedCustomer,
    ...customersData.slice(customerIndex + 1),
  ];

  // 6. Return the updated `Customer` object.
  return updatedCustomer;
}

/**
 * Marks a customer's profile as inactive, preventing further active interactions.
 * @param {string} customerId - The unique identifier of the customer to deactivate.
 * @returns {ReturnType<typeof Customer>}
 * @throws {Error} If the customer is not found.
 */
export function deactivateCustomer(customerId) {
  // 1. Locate the customer by `customerId`.
  const customerIndex = customersData.findIndex(c => c.id === customerId);

  // 2. IF the customer is not found THEN indicate an error.
  if (customerIndex === -1) {
    throw new Error(`Customer with ID ${customerId} not found.`);
  }

  const existingCustomer = customersData[customerIndex];

  // 3. Update the customer's status to 'inactive'.
  // Create a new customer object to ensure immutability.
  const deactivatedCustomer = Customer({
    ...existingCustomer,
    status: CustomerStatus.INACTIVE,
    updatedAt: new Date(), // Always update timestamp on modification
  });

  // 4. Persist the change in the data store.
  // Replace the old customer object with the new one immutably.
  customersData = [
    ...customersData.slice(0, customerIndex),
    deactivatedCustomer,
    ...customersData.slice(customerIndex + 1),
  ];

  // 5. Return the updated `Customer` object.
  return deactivatedCustomer;
}