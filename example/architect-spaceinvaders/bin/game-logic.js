/**
 * ðŸ›‘ DO NOT EDIT THIS FILE DIRECTLY
 * ----------------------------------
 * This file was generated by ISL Compiler.
 * Source: game-logic.isl.md
 * Edit the ISL file instead.
 */

import {
  GameStatusEnum,
  EntityTypeEnum,
  DirectionEnum,
  PlayerActionEnum,
  InvaderTypeEnum,
  Position,
  Size,
  PlayerState,
  InvaderState,
  BulletState,
  ShieldSegmentState,
  LevelConfig,
  GameConfig,
  GameConstants,
} from './game-domain';

// Helper for unique IDs
const generateUniqueId = () => Math.random().toString(36).substring(2, 9);

// AABB Collision Detection
const aabbCollision = (rect1, rect2) => {
  return (
    rect1.position.x < rect2.position.x + rect2.size.width &&
    rect1.position.x + rect1.size.width > rect2.position.x &&
    rect1.position.y < rect2.position.y + rect2.size.height &&
    rect1.position.y + rect1.size.height > rect2.position.y
  );
};

/**
 * GameLogic factory function.
 * Initializes game logic capabilities based on the provided game configuration.
 * @param {object} initialGameConfig - The initial game configuration data.
 * @returns {object} An object containing game logic capabilities.
 */
export const GameLogic = (initialGameConfig) => {
  // Instantiate GameConfig and GameConstants once.
  // GameConfig is expected to be an instance, but the signature implies it's a factory input.
  // We'll treat initialGameConfig as the data for the GameConfig factory.
  const gameConfig = GameConfig(initialGameConfig);
  const gameConstants = GameConstants(); // Assuming default constants are sufficient as no data is passed for them.

  // Derived constants for internal use
  const PLAYER_Y_POSITION = gameConfig.canvasHeight - gameConstants.PLAYER_START_Y_OFFSET - gameConstants.PLAYER_HEIGHT;
  // These intervals are not explicitly in GameConstants, so we define reasonable defaults.
  // Invader movement interval: how often they take a step.
  const INVADER_MOVEMENT_STEP_INTERVAL_MS = 500; // milliseconds
  // Invader descent interval: how long after hitting edge before they descend.
  const INVADER_DESCENT_COOLDOWN_MS = 1000; // milliseconds

  /**
   * Helper to get LevelConfig for a given level number.
   * NOTE: The ISL flow states "Load currentLevelConfig by finding the LevelConfig for levelNumber = 1 from gameConfig.levelConfigs."
   * However, the provided `GameConfig` signature in REAL IMPLEMENTATION CONTEXT does NOT include `levelConfigs`.
   * Therefore, this function dynamically generates a LevelConfig based on the levelNumber and global gameConfig parameters.
   * @param {number} levelNumber - The current level number.
   * @returns {object} A LevelConfig instance.
   */
  const getLevelConfig = (levelNumber) => {
    const baseInvaderRows = 5;
    const baseInvaderCols = 10;

    // Dynamically generate default shield configuration based on gameConfig.shieldCount
    const defaultShieldConfiguration = [];
    const shieldBlockWidth = gameConstants.SHIELD_SEGMENT_WIDTH * 3; // Assuming 3 segments wide per block
    const totalShieldsWidth = gameConfig.shieldCount * shieldBlockWidth;
    const spacingBetweenShieldBlocks = (gameConfig.canvasWidth - totalShieldsWidth) / (gameConfig.shieldCount + 1);
    const shieldY = gameConfig.canvasHeight * 0.75; // Example Y position for shields

    for (let i = 0; i < gameConfig.shieldCount; i++) {
      const blockStartX = spacingBetweenShieldBlocks * (i + 1) + i * shieldBlockWidth;
      for (let r = 0; r < 2; r++) { // 2 rows of segments per block
        for (let c = 0; c < 3; c++) { // 3 columns of segments per block
          defaultShieldConfiguration.push(Position({
            x: blockStartX + c * gameConstants.SHIELD_SEGMENT_WIDTH,
            y: shieldY + r * gameConstants.SHIELD_SEGMENT_HEIGHT
          }));
        }
      }
    }

    return LevelConfig({
      levelNumber: levelNumber,
      invaderRows: baseInvaderRows,
      invaderCols: baseInvaderCols,
      invaderSpeedMultiplier: 1 + (levelNumber - 1) * 0.1, // 10% faster per level
      invaderBulletSpeedMultiplier: 1 + (levelNumber - 1) * 0.05, // 5% faster per level
      invaderShotFrequencyMultiplier: Math.max(0.1, 1 - (levelNumber - 1) * 0.02), // 2% more frequent per level, min 0.1
      playerBulletSpeedMultiplier: 1,
      playerSpeedMultiplier: 1,
      initialPlayerLives: gameConfig.initialLives,
      shieldConfiguration: defaultShieldConfiguration,
    });
  };

  /**
   * Helper to create the initial PlayerState.
   * @returns {object} A PlayerState instance.
   */
  const createInitialPlayerState = () => {
    return PlayerState({
      position: Position({
        x: (gameConfig.canvasWidth - gameConstants.PLAYER_WIDTH) / 2,
        y: PLAYER_Y_POSITION,
      }),
      size: Size({ width: gameConstants.PLAYER_WIDTH, height: gameConstants.PLAYER_HEIGHT }),
      speed: gameConfig.playerBaseSpeed,
      lives: gameConfig.initialLives,
      isShooting: false,
      lastShotTime: 0,
    });
  };

  /**
   * Helper to create invaders for a given level configuration.
   * @param {object} levelConfig - The LevelConfig for the current level.
   * @returns {Array<object>} An array of InvaderState instances.
   */
  const createInvaders = (levelConfig) => {
    const invaders = [];
    const invaderWidth = gameConstants.INVADER_WIDTH;
    const invaderHeight = gameConstants.INVADER_HEIGHT;
    const horizontalSpacing = gameConfig.invaderHorizontalSpacing;
    const verticalSpacing = gameConfig.invaderVerticalSpacing;

    const totalInvaderWidth = levelConfig.invaderCols * (invaderWidth + horizontalSpacing) - horizontalSpacing;
    const startX = (gameConfig.canvasWidth - totalInvaderWidth) / 2;

    for (let row = 0; row < levelConfig.invaderRows; row++) {
      for (let col = 0; col < levelConfig.invaderCols; col++) {
        const invaderType =
          row === 0 ? InvaderTypeEnum.TYPE_A :
          row === 1 || row === 2 ? InvaderTypeEnum.TYPE_B :
          InvaderTypeEnum.TYPE_C;

        invaders.push(
          InvaderState({
            id: generateUniqueId(),
            position: Position({
              x: startX + col * (invaderWidth + horizontalSpacing),
              y: gameConstants.INVADER_START_Y_OFFSET + row * (invaderHeight + verticalSpacing),
            }),
            size: Size({ width: invaderWidth, height: invaderHeight }),
            type: invaderType,
            isAlive: true,
            direction: DirectionEnum.RIGHT, // Fleet direction is managed externally
            speed: gameConfig.invaderBaseSpeed * levelConfig.invaderSpeedMultiplier,
            points: invaderType === InvaderTypeEnum.UFO ? gameConfig.scorePerUFO : gameConfig.scorePerInvader,
          })
        );
      }
    }
    return invaders;
  };

  /**
   * Helper to create shield segments based on a level configuration.
   * @param {object} levelConfig - The LevelConfig for the current level.
   * @returns {Array<object>} An array of ShieldSegmentState instances.
   */
  const createShields = (levelConfig) => {
    const shields = [];
    const shieldSegmentWidth = gameConstants.SHIELD_SEGMENT_WIDTH;
    const shieldSegmentHeight = gameConstants.SHIELD_SEGMENT_HEIGHT;
    const shieldHealth = gameConfig.shieldSegmentHealth;

    levelConfig.shieldConfiguration.forEach((pos) => {
      shields.push(
        ShieldSegmentState({
          id: generateUniqueId(),
          position: Position(pos),
          size: Size({ width: shieldSegmentWidth, height: shieldSegmentHeight }),
          health: shieldHealth,
          isDestroyed: false,
        })
      );
    });
    return shields;
  };

  /**
   * Helper to select a random invader from the bottom row of each column for shooting.
   * @param {Array<object>} invaders - List of active invaders.
   * @returns {object|null} A random InvaderState or null if no invaders.
   */
  const getRandomInvaderToShoot = (invaders) => {
    if (invaders.length === 0) return null;

    // Group invaders by column (using x position for grouping)
    const invadersByColumn = new Map();
    invaders.forEach(invader => {
      // Round x to nearest multiple of invaderWidth + horizontalSpacing to group into columns
      const colKey = Math.round(invader.position.x / (gameConstants.INVADER_WIDTH + gameConfig.invaderHorizontalSpacing));
      if (!invadersByColumn.has(colKey)) {
        invadersByColumn.set(colKey, []);
      }
      invadersByColumn.get(colKey).push(invader);
    });

    const bottomInvaders = [];
    invadersByColumn.forEach(columnInvaders => {
      // Find the invader with the maximum Y position in this column
      const bottomMost = columnInvaders.reduce((prev, current) =>
        (prev.position.y > current.position.y ? prev : current)
      );
      bottomInvaders.push(bottomMost);
    });

    if (bottomInvaders.length === 0) return null;

    // Pick a random invader from the bottom-most ones
    const randomIndex = Math.floor(Math.random() * bottomInvaders.length);
    return bottomInvaders[randomIndex];
  };

  /**
   * Internal factory function to create a new GameState object, ensuring all properties are present with defaults.
   * @param {object} data - Partial GameState data to override defaults.
   * @returns {object} A complete GameState object.
   */
  const createGameState = (data = {}) => {
    const levelNumber = data.levelNumber ?? 1;
    const currentLevelConfig = data.currentLevelConfig ?? getLevelConfig(levelNumber);

    return {
      status: data.status ?? GameStatusEnum.INITIAL,
      levelNumber: levelNumber,
      score: data.score ?? 0,
      playerState: data.playerState ?? createInitialPlayerState(),
      invadersState: data.invadersState ?? [],
      playerBullets: data.playerBullets ?? [],
      invaderBullets: data.invaderBullets ?? [],
      shieldStates: data.shieldStates ?? [],
      lastUpdateTime: data.lastUpdateTime ?? Date.now(),
      gameConfig: data.gameConfig ?? gameConfig,
      currentLevelConfig: currentLevelConfig,
      playerActionFlags: data.playerActionFlags ?? { moveLeft: false, moveRight: false, isShooting: false },
      invaderDirection: data.invaderDirection ?? 1, // 1 for right, -1 for left
      invaderMovementTimer: data.invaderMovementTimer ?? 0,
      invaderDescentTimer: data.invaderDescentTimer ?? 0,
      invaderShotTimer: data.invaderShotTimer ?? 0,
      playerShotCooldownTimer: data.playerShotCooldownTimer ?? 0,
    };
  };

  /**
   * Prepares the initial game state, setting up default values and the first level's configuration.
   * @returns {object} The initial GameState.
   */
  const initializeGame = () => {
    const initialLevelConfig = getLevelConfig(1);
    return createGameState({
      status: GameStatusEnum.INITIAL,
      score: 0,
      levelNumber: 1,
      playerState: createInitialPlayerState(),
      invadersState: [],
      playerBullets: [],
      invaderBullets: [],
      shieldStates: [],
      lastUpdateTime: Date.now(),
      gameConfig: gameConfig,
      currentLevelConfig: initialLevelConfig,
      playerActionFlags: { moveLeft: false, moveRight: false, isShooting: false },
      invaderDirection: 1,
      invaderMovementTimer: 0,
      invaderDescentTimer: 0,
      invaderShotTimer: 0,
      playerShotCooldownTimer: 0,
    });
  };

  /**
   * Transitions the game from INITIAL to PLAYING and sets up the first level's entities.
   * @param {object} initialState - The current GameState.
   * @returns {object} The updated GameState.
   */
  const startGame = (initialState) => {
    if (initialState.status !== GameStatusEnum.INITIAL) {
      return createGameState(initialState); // Return unchanged if not in initial state
    }

    const currentLevelConfig = getLevelConfig(1); // Ensure level 1 config
    const newPlayerState = createInitialPlayerState(); // Reset player state

    return createGameState({
      ...initialState,
      status: GameStatusEnum.PLAYING,
      score: 0,
      levelNumber: 1,
      playerState: newPlayerState,
      invadersState: createInvaders(currentLevelConfig),
      shieldStates: createShields(currentLevelConfig),
      playerBullets: [],
      invaderBullets: [],
      invaderDirection: 1,
      invaderMovementTimer: 0,
      invaderDescentTimer: 0,
      invaderShotTimer: 0,
      playerShotCooldownTimer: 0,
      lastUpdateTime: Date.now(),
      currentLevelConfig: currentLevelConfig,
    });
  };

  /**
   * Updates the player's action flags within the game state based on discrete player input events.
   * @param {object} currentState - The current GameState.
   * @param {'MOVE_LEFT'|'MOVE_RIGHT'|'SHOOT'} action - The player action.
   * @param {boolean} isPressed - True if the action button is pressed, false otherwise.
   * @returns {object} The updated GameState.
   */
  const processPlayerInput = (currentState, action, isPressed) => {
    const newPlayerActionFlags = { ...currentState.playerActionFlags };

    if (action === PlayerActionEnum.MOVE_LEFT) {
      newPlayerActionFlags.moveLeft = isPressed;
    } else if (action === PlayerActionEnum.MOVE_RIGHT) {
      newPlayerActionFlags.moveRight = isPressed;
    } else if (action === PlayerActionEnum.SHOOT) {
      newPlayerActionFlags.isShooting = isPressed;
    }

    return createGameState({
      ...currentState,
      playerActionFlags: newPlayerActionFlags,
    });
  };

  /**
   * Advances the game state by one frame, handling movement, shooting, collisions, and game progression.
   * This is the core of the game loop.
   * @param {object} currentState - The current GameState.
   * @param {number} currentTime - The current timestamp in milliseconds.
   * @returns {object} The updated GameState.
   */
  const updateGame = (currentState, currentTime) => {
    if (currentState.status !== GameStatusEnum.PLAYING) {
      return createGameState(currentState);
    }

    let newState = createGameState(currentState);
    const deltaTime = Math.max(0, currentTime - newState.lastUpdateTime); // Ensure non-negative deltaTime
    const dtSeconds = deltaTime / 1000;

    newState = createGameState({
      ...newState,
      lastUpdateTime: currentTime,
      playerShotCooldownTimer: Math.max(0, newState.playerShotCooldownTimer - deltaTime),
      invaderMovementTimer: Math.max(0, newState.invaderMovementTimer - deltaTime),
      invaderDescentTimer: Math.max(0, newState.invaderDescentTimer - deltaTime),
      invaderShotTimer: Math.max(0, newState.invaderShotTimer - deltaTime),
    });

    // --- Player Movement ---
    let newPlayerPositionX = newState.playerState.position.x;
    const playerSpeed = newState.playerState.speed * newState.currentLevelConfig.playerSpeedMultiplier;

    if (newState.playerActionFlags.moveLeft) {
      newPlayerPositionX -= playerSpeed * dtSeconds;
    }
    if (newState.playerActionFlags.moveRight) {
      newPlayerPositionX += playerSpeed * dtSeconds;
    }

    // Clamp player position within canvas bounds
    newPlayerPositionX = Math.max(
      0,
      Math.min(gameConfig.canvasWidth - newState.playerState.size.width, newPlayerPositionX)
    );

    newState = createGameState({
      ...newState,
      playerState: PlayerState({
        ...newState.playerState,
        position: Position({ ...newState.playerState.position, x: newPlayerPositionX }),
      }),
    });

    // --- Player Shooting ---
    if (newState.playerActionFlags.isShooting && newState.playerShotCooldownTimer <= 0) {
      const newPlayerBullet = BulletState({
        id: generateUniqueId(),
        position: Position({
          x: newState.playerState.position.x + newState.playerState.size.width / 2 - gameConstants.BULLET_WIDTH / 2,
          y: newState.playerState.position.y,
        }),
        size: Size({ width: gameConstants.BULLET_WIDTH, height: gameConstants.BULLET_HEIGHT }),
        speed: gameConfig.playerBulletBaseSpeed * newState.currentLevelConfig.playerBulletSpeedMultiplier,
        direction: DirectionEnum.UP,
        owner: EntityTypeEnum.PLAYER,
        isAlive: true,
      });
      newState = createGameState({
        ...newState,
        playerBullets: [...newState.playerBullets, newPlayerBullet],
        playerShotCooldownTimer: gameConfig.playerBulletCooldown,
      });
    }

    // --- Invader Movement ---
    let newInvadersState = [...newState.invadersState];
    let newInvaderDirection = newState.invaderDirection;
    let newInvaderDescentTimer = newState.invaderDescentTimer;

    if (newState.invaderMovementTimer <= 0) {
      const invaderSpeed = gameConfig.invaderBaseSpeed * newState.currentLevelConfig.invaderSpeedMultiplier;
      const moveDistance = invaderSpeed * (INVADER_MOVEMENT_STEP_INTERVAL_MS / 1000); // Distance per step

      let hitEdge = false;
      let minX = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;

      newInvadersState = newInvadersState.map(invader => {
        const newX = invader.position.x + newInvaderDirection * moveDistance;
        minX = Math.min(minX, newX);
        maxX = Math.max(maxX, newX + invader.size.width);
        maxY = Math.max(maxY, invader.position.y + invader.size.height);
        return InvaderState({
          ...invader,
          position: Position({ ...invader.position, x: newX }),
        });
      });

      if (minX <= gameConstants.INVADER_MIN_X_OFFSET || maxX >= gameConfig.canvasWidth - gameConstants.INVADER_MAX_X_OFFSET) {
        hitEdge = true;
      }

      if (hitEdge) {
        newInvaderDirection = -newInvaderDirection;
        newInvadersState = newInvadersState.map(invader =>
          InvaderState({
            ...invader,
            position: Position({ ...invader.position, y: invader.position.y + gameConfig.invaderDescentAmount }),
          })
        );
        newInvaderDescentTimer = INVADER_DESCENT_COOLDOWN_MS; // Reset descent timer
      }

      newState = createGameState({
        ...newState,
        invadersState: newInvadersState,
        invaderDirection: newInvaderDirection,
        invaderMovementTimer: INVADER_MOVEMENT_STEP_INTERVAL_MS, // Reset movement timer
        invaderDescentTimer: newInvaderDescentTimer,
      });

      // Check for game over if any invader's position.y + size.height is >= GameConstants.playerYPosition
      if (newInvadersState.some(invader => invader.position.y + invader.size.height >= PLAYER_Y_POSITION)) {
        newState = createGameState({ ...newState, status: GameStatusEnum.GAME_OVER });
      }
    }

    // --- Invader Shooting ---
    let newInvaderBullets = [...newState.invaderBullets];
    if (newState.invaderShotTimer <= 0 && newState.invadersState.length > 0) {
      const invaderToShoot = getRandomInvaderToShoot(newState.invadersState);
      if (invaderToShoot) {
        const newBullet = BulletState({
          id: generateUniqueId(),
          position: Position({
            x: invaderToShoot.position.x + invaderToShoot.size.width / 2 - gameConstants.BULLET_WIDTH / 2,
            y: invaderToShoot.position.y + invaderToShoot.size.height,
          }),
          size: Size({ width: gameConstants.BULLET_WIDTH, height: gameConstants.BULLET_HEIGHT }),
          speed: gameConfig.invaderBulletBaseSpeed * newState.currentLevelConfig.invaderBulletSpeedMultiplier,
          direction: DirectionEnum.DOWN,
          owner: EntityTypeEnum.INVADER,
          isAlive: true,
        });
        newInvaderBullets.push(newBullet);
      }
      newState = createGameState({
        ...newState,
        invaderBullets: newInvaderBullets,
        invaderShotTimer: gameConfig.invaderShotBaseFrequency * newState.currentLevelConfig.invaderShotFrequencyMultiplier,
      });
    }

    // --- Bullet Movement ---
    let updatedPlayerBullets = newState.playerBullets.map(bullet =>
      BulletState({
        ...bullet,
        position: Position({ ...bullet.position, y: bullet.position.y - bullet.speed * dtSeconds }),
      })
    ).filter(bullet => bullet.position.y + bullet.size.height > 0); // Remove off-screen bullets

    let updatedInvaderBullets = newState.invaderBullets.map(bullet =>
      BulletState({
        ...bullet,
        position: Position({ ...bullet.position, y: bullet.position.y + bullet.speed * dtSeconds }),
      })
    ).filter(bullet => bullet.position.y < gameConfig.canvasHeight); // Remove off-screen bullets

    newState = createGameState({
      ...newState,
      playerBullets: updatedPlayerBullets,
      invaderBullets: updatedInvaderBullets,
    });

    // --- Collision Detection ---
    let newScore = newState.score;
    let newPlayerLives = newState.playerState.lives;
    let newShieldStates = [...newState.shieldStates];

    // Player Bullets vs. Invaders
    const remainingInvaders = [];
    const hitPlayerBulletsIds = new Set();
    for (const invader of newState.invadersState) {
      let invaderHit = false;
      for (const bullet of newState.playerBullets) {
        if (!hitPlayerBulletsIds.has(bullet.id) && aabbCollision(bullet, invader)) {
          hitPlayerBulletsIds.add(bullet.id);
          newScore += invader.points;
          invaderHit = true;
          break; // Bullet can only hit one invader
        }
      }
      if (!invaderHit) {
        remainingInvaders.push(invader);
      }
    }
    newState = createGameState({ ...newState, invadersState: remainingInvaders, score: newScore });
    updatedPlayerBullets = updatedPlayerBullets.filter(bullet => !hitPlayerBulletsIds.has(bullet.id));

    // Player Bullets vs. Shields
    const remainingShieldsAfterPlayerBullets = [];
    const hitShieldsByPlayerBulletIds = new Set();
    for (const shield of newShieldStates) {
      let shieldHit = false;
      for (const bullet of updatedPlayerBullets) {
        if (!hitShieldsByPlayerBulletIds.has(bullet.id) && aabbCollision(bullet, shield)) {
          hitShieldsByPlayerBulletIds.add(bullet.id);
          shieldHit = true;
          const newHealth = shield.health - 1;
          if (newHealth > 0) {
            remainingShieldsAfterPlayerBullets.push(ShieldSegmentState({ ...shield, health: newHealth }));
          } else {
            // Shield destroyed
          }
          break;
        }
      }
      if (!shieldHit) {
        remainingShieldsAfterPlayerBullets.push(shield);
      }
    }
    newShieldStates = remainingShieldsAfterPlayerBullets;
    updatedPlayerBullets = updatedPlayerBullets.filter(bullet => !hitShieldsByPlayerBulletIds.has(bullet.id));
    newState = createGameState({ ...newState, playerBullets: updatedPlayerBullets, shieldStates: newShieldStates });


    // Invader Bullets vs. Player
    const remainingInvaderBullets = [];
    let playerHitThisFrame = false;
    for (const bullet of updatedInvaderBullets) {
      if (aabbCollision(bullet, newState.playerState)) {
        playerHitThisFrame = true;
        newPlayerLives -= 1;
        // Player hit, clear all bullets and reset player position
        newState = createGameState({
          ...newState,
          playerState: PlayerState({ ...newState.playerState, lives: newPlayerLives, position: createInitialPlayerState().position }),
          playerBullets: [], // Clear all player bullets
          invaderBullets: [], // Clear all invader bullets
        });
        break; // Player can only be hit by one invader bullet per frame
      } else {
        remainingInvaderBullets.push(bullet);
      }
    }
    newState = createGameState({ ...newState, invaderBullets: remainingInvaderBullets });

    if (playerHitThisFrame && newPlayerLives <= 0) {
      newState = createGameState({ ...newState, status: GameStatusEnum.GAME_OVER });
    } else if (playerHitThisFrame) {
      newState = createGameState({ ...newState, playerState: PlayerState({ ...newState.playerState, lives: newPlayerLives }) });
    }


    // Invader Bullets vs. Shields
    const finalShieldStates = [];
    const hitShieldsByInvaderBulletIds = new Set();
    for (const shield of newState.shieldStates) {
      let shieldHit = false;
      for (const bullet of newState.invaderBullets) {
        if (!hitShieldsByInvaderBulletIds.has(bullet.id) && aabbCollision(bullet, shield)) {
          hitShieldsByInvaderBulletIds.add(bullet.id);
          shieldHit = true;
          const newHealth = shield.health - 1;
          if (newHealth > 0) {
            finalShieldStates.push(ShieldSegmentState({ ...shield, health: newHealth }));
          } else {
            // Shield destroyed
          }
          break;
        }
      }
      if (!shieldHit) {
        finalShieldStates.push(shield);
      }
    }
    newState = createGameState({ ...newState, shieldStates: finalShieldStates });
    newState = createGameState({ ...newState, invaderBullets: newState.invaderBullets.filter(bullet => !hitShieldsByInvaderBulletIds.has(bullet.id)) });


    // --- Game State Checks ---
    // Level Completion
    if (newState.invadersState.length === 0) {
      if (newState.levelNumber < gameConfig.maxLevels) {
        newState = loadNextLevel(newState);
      } else {
        newState = createGameState({ ...newState, status: GameStatusEnum.GAME_WON });
      }
    }

    // Game Over (Invaders reached bottom) - already checked during invader movement
    // Game Over (Player out of lives) - already checked after invader bullet collision

    return newState;
  };

  /**
   * Prepares the game for the next level, incrementing the level number, resetting entities, and applying new level configurations.
   * @param {object} currentState - The current GameState.
   * @returns {object} The updated GameState.
   */
  const loadNextLevel = (currentState) => {
    let newState = createGameState(currentState);
    const nextLevelNumber = newState.levelNumber + 1;

    if (nextLevelNumber > gameConfig.maxLevels) {
      return createGameState({ ...newState, status: GameStatusEnum.GAME_WON });
    }

    const nextLevelConfig = getLevelConfig(nextLevelNumber);
    const newPlayerState = PlayerState({ ...newState.playerState, position: createInitialPlayerState().position });

    return createGameState({
      ...newState,
      levelNumber: nextLevelNumber,
      currentLevelConfig: nextLevelConfig,
      playerState: newPlayerState,
      invadersState: createInvaders(nextLevelConfig),
      shieldStates: createShields(nextLevelConfig),
      playerBullets: [],
      invaderBullets: [],
      invaderDirection: 1,
      invaderMovementTimer: 0,
      invaderDescentTimer: 0,
      invaderShotTimer: 0,
      playerShotCooldownTimer: 0,
      lastUpdateTime: Date.now(),
      score: newState.score + gameConfig.scorePerLevelClear, // Bonus score for clearing level
    });
  };

  /**
   * Resets the entire game state to its initial INITIAL status, ready for a new game start.
   * @param {object} currentState - The current GameState.
   * @returns {object} The reset GameState.
   */
  const resetGame = (currentState) => {
    const initialLevelConfig = getLevelConfig(1);
    return createGameState({
      ...currentState,
      status: GameStatusEnum.INITIAL,
      score: 0,
      levelNumber: 1,
      playerState: createInitialPlayerState(),
      invadersState: [],
      playerBullets: [],
      invaderBullets: [],
      shieldStates: [],
      playerActionFlags: { moveLeft: false, moveRight: false, isShooting: false },
      invaderDirection: 1,
      invaderMovementTimer: 0,
      invaderDescentTimer: 0,
      invaderShotTimer: 0,
      playerShotCooldownTimer: 0,
      lastUpdateTime: Date.now(),
      currentLevelConfig: initialLevelConfig,
    });
  };

  return {
    initializeGame,
    startGame,
    processPlayerInput,
    updateGame,
    loadNextLevel,
    resetGame,
  };
};