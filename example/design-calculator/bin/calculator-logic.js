/**
 * ðŸ›‘ DO NOT EDIT THIS FILE DIRECTLY
 * ----------------------------------
 * This file was generated by ISL Compiler.
 * Source: calculator-logic.isl.md
 * Edit the ISL file instead.
 */

import { OperationType, CalculatorStateEntity } from "./domain";

/**
 * Sets the calculator's state to its initial default values.
 * @returns {object} The initialized CalculatorStateEntity.
 */
export const initializeState = () => {
  return CalculatorStateEntity({
    currentOperand: "0",
    previousOperand: "",
    operator: null,
    displayValue: "0",
    waitingForNewOperand: false,
    isError: false,
  });
};

/**
 * Performs the actual arithmetic operation between two numbers.
 * @param {string} operand1Str - The first operand as a string.
 * @param {string} operand2Str - The second operand as a string.
 * @param {OperationType} operator - The operation type.
 * @returns {number | Error} The result of the calculation or an Error object if division by zero occurs.
 */
export const _executeCalculation = (operand1Str, operand2Str, operator) => {
  const operand1 = parseFloat(operand1Str);
  const operand2 = parseFloat(operand2Str);

  if (isNaN(operand1) || isNaN(operand2)) {
    // This case should ideally be prevented by input validation upstream,
    // but as a safety measure, return 0 or an error.
    return 0;
  }

  switch (operator) {
    case OperationType.ADD:
      return operand1 + operand2;
    case OperationType.SUBTRACT:
      return operand1 - operand2;
    case OperationType.MULTIPLY:
      return operand1 * operand2;
    case OperationType.DIVIDE:
      if (operand2 === 0) {
        return new Error("Division by zero");
      }
      return operand1 / operand2;
    default:
      return 0; // Should not happen with valid OperationType
  }
};

/**
 * Processes a numeric digit input, updating the current operand and display.
 * @param {object} state - The current CalculatorStateEntity.
 * @param {string} digit - The digit to process.
 * @returns {object} The updated CalculatorStateEntity.
 */
export const processDigit = (state, digit) => {
  if (state.isError) {
    return initializeState();
  }

  let newCurrentOperand = state.currentOperand;
  let newWaitingForNewOperand = state.waitingForNewOperand;

  if (state.waitingForNewOperand) {
    newCurrentOperand = digit;
    newWaitingForNewOperand = false;
  } else if (state.currentOperand === "0") {
    newCurrentOperand = digit;
  } else {
    newCurrentOperand += digit;
  }

  return CalculatorStateEntity({
    ...state,
    currentOperand: newCurrentOperand,
    displayValue: newCurrentOperand,
    waitingForNewOperand: newWaitingForNewOperand,
  });
};

/**
 * Adds a decimal point to the current operand if not already present.
 * @param {object} state - The current CalculatorStateEntity.
 * @returns {object} The updated CalculatorStateEntity.
 */
export const processDecimal = (state) => {
  if (state.isError) {
    return initializeState();
  }

  let newCurrentOperand = state.currentOperand;
  let newWaitingForNewOperand = state.waitingForNewOperand;

  if (state.waitingForNewOperand) {
    newCurrentOperand = "0.";
    newWaitingForNewOperand = false;
  } else if (!state.currentOperand.includes(".")) {
    newCurrentOperand += ".";
  }

  return CalculatorStateEntity({
    ...state,
    currentOperand: newCurrentOperand,
    displayValue: newCurrentOperand,
    waitingForNewOperand: newWaitingForNewOperand,
  });
};

/**
 * Stores the selected operator and performs any pending calculation if a previous operator exists.
 * @param {object} state - The current CalculatorStateEntity.
 * @param {OperationType} newOperator - The new operator to process.
 * @returns {object} The updated CalculatorStateEntity.
 */
export const processOperator = (state, newOperator) => {
  if (state.isError) {
    return initializeState();
  }

  let newState = { ...state };

  if (
    newState.previousOperand !== "" &&
    newState.operator !== null &&
    newState.waitingForNewOperand === false
  ) {
    const calculationResult = _executeCalculation(
      newState.previousOperand,
      newState.currentOperand,
      newState.operator
    );

    if (calculationResult instanceof Error) {
      return CalculatorStateEntity({
        ...newState,
        isError: true,
        displayValue: "Error",
      });
    }
    newState.currentOperand = calculationResult.toString();
  }

  newState.previousOperand = newState.currentOperand;
  newState.operator = newOperator;
  newState.waitingForNewOperand = true;
  newState.displayValue = newState.currentOperand;

  return CalculatorStateEntity(newState);
};

/**
 * Triggers the final calculation using the stored operands and operator.
 * @param {object} state - The current CalculatorStateEntity.
 * @returns {object} The updated CalculatorStateEntity.
 */
export const processEquals = (state) => {
  if (state.isError) {
    return initializeState();
  }

  let newState = { ...state };

  if (newState.previousOperand !== "" && newState.operator !== null) {
    const calculationResult = _executeCalculation(
      newState.previousOperand,
      newState.currentOperand,
      newState.operator
    );

    if (calculationResult instanceof Error) {
      return CalculatorStateEntity({
        ...newState,
        isError: true,
        displayValue: "Error",
      });
    }
    newState.currentOperand = calculationResult.toString();
    newState.previousOperand = "";
    newState.operator = null;
    newState.waitingForNewOperand = true;
    newState.displayValue = newState.currentOperand;
  }

  return CalculatorStateEntity(newState);
};

/**
 * Resets the calculator to its initial state.
 * @param {object} state - The current CalculatorStateEntity (not directly used, but kept for signature consistency).
 * @returns {object} The initialized CalculatorStateEntity.
 */
export const clear = (state) => {
  return initializeState();
};

/**
 * Changes the sign of the current operand.
 * @param {object} state - The current CalculatorStateEntity.
 * @returns {object} The updated CalculatorStateEntity.
 */
export const toggleSign = (state) => {
  if (state.isError) {
    return initializeState();
  }

  const numericOperand = parseFloat(state.currentOperand);
  if (isNaN(numericOperand)) {
    // If currentOperand is not a valid number, return current state or handle as error
    return CalculatorStateEntity(state);
  }

  const newCurrentOperand = (numericOperand * -1).toString();

  return CalculatorStateEntity({
    ...state,
    currentOperand: newCurrentOperand,
    displayValue: newCurrentOperand,
  });
};