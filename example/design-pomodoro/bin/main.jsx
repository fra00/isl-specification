/**
 * ðŸ›‘ DO NOT EDIT THIS FILE DIRECTLY
 * ----------------------------------
 * This file was generated by ISL Compiler.
 * Source: main.isl.md
 * Edit the ISL file instead.
 */

import React, { useState, useEffect, useRef } from 'react';
import { TimerMode, TimerState, TimerConfigEntity } from './domain';
import { PomodoroEngine } from './logic';
import TimerDisplay, { ControlButtons } from './ui';

export default function Main() {
  // State to reflect the PomodoroEngine's observable properties
  const [remainingTime, setRemainingTime] = useState(0);
  const [currentMode, setCurrentMode] = useState(TimerMode.Work);
  const [currentState, setCurrentState] = useState(TimerState.Idle);

  // useRef to hold the PomodoroEngine instance, ensuring stability across renders
  const engineRef = useRef(null);
  // useRef for the interval ID to manage periodic updates
  const intervalRef = useRef(null);

  // Capability: initializeApplication
  useEffect(() => {
    // 1. Create an instance of PomodoroEngine with default TimerConfigEntity
    const initialConfig = TimerConfigEntity({
      workDuration: 1500, // 25 minutes
      shortBreakDuration: 300, // 5 minutes
      longBreakDuration: 900, // 15 minutes
    });
    const engine = PomodoroEngine(initialConfig);
    engineRef.current = engine; // Store the engine instance

    // 2. Call PomodoroEngine.initialize()
    engine.initialize();

    // Initial state update for UI
    setRemainingTime(engine.getRemainingTime());
    setCurrentMode(engine.getCurrentMode());
    setCurrentState(engine.getCurrentState());

    // Cleanup function: clear any running interval when the component unmounts
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []); // Empty dependency array ensures this runs only once on mount

  // Effect to manage the periodic polling of the PomodoroEngine's state
  useEffect(() => {
    const engine = engineRef.current;
    if (!engine) return; // Ensure engine is initialized

    if (currentState === TimerState.Running) {
      // Clear any existing interval before setting a new one
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
      // 3. Establish a mechanism to periodically poll PomodoroEngine's state every 1 second
      // (Note: As per REAL IMPLEMENTATION CONTEXT, PomodoroEngine.tick() is not exposed.
      // We poll the engine's observable state instead, assuming the engine manages its own internal timing.)
      intervalRef.current = setInterval(() => {
        setRemainingTime(engine.getRemainingTime());
        setCurrentMode(engine.getCurrentMode());
        setCurrentState(engine.getCurrentState());

        // If the engine's internal state changes to not running, stop the interval immediately
        if (engine.getCurrentState() !== TimerState.Running) {
          clearInterval(intervalRef.current);
          intervalRef.current = null;
        }
      }, 1000); // Every 1 second
    } else {
      // If the timer is not running, ensure the interval is cleared
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    }

    // Cleanup function: clear the interval when the effect re-runs or component unmounts
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    };
  }, [currentState]); // Re-run this effect when currentState changes

  // Helper to safely get the engine instance and ensure it's initialized
  const getEngine = () => {
    if (!engineRef.current) {
      // Fallback/error handling: Re-initialize if for some reason it's null
      console.error("PomodoroEngine not initialized, attempting re-initialization.");
      const initialConfig = TimerConfigEntity({
        workDuration: 1500,
        shortBreakDuration: 300,
        longBreakDuration: 900,
      });
      engineRef.current = PomodoroEngine(initialConfig);
      engineRef.current.initialize();
    }
    return engineRef.current;
  };

  // Expose PomodoroEngine's actions as stable callbacks
  const handleStart = () => {
    const engine = getEngine();
    engine.startTimer();
    // Immediately update UI state after action
    setRemainingTime(engine.getRemainingTime());
    setCurrentMode(engine.getCurrentMode());
    setCurrentState(engine.getCurrentState());
  };

  const handlePause = () => {
    const engine = getEngine();
    engine.pauseTimer();
    // Immediately update UI state after action
    setRemainingTime(engine.getRemainingTime());
    setCurrentMode(engine.getCurrentMode());
    setCurrentState(engine.getCurrentState());
  };

  const handleReset = () => {
    const engine = getEngine();
    engine.resetTimer();
    // Immediately update UI state after action
    setRemainingTime(engine.getRemainingTime());
    setCurrentMode(engine.getCurrentMode());
    setCurrentState(engine.getCurrentState());
  };

  const handleSelectMode = (mode) => {
    const engine = getEngine();
    engine.selectMode(mode);
    // Immediately update UI state after action
    setRemainingTime(engine.getRemainingTime());
    setCurrentMode(engine.getCurrentMode());
    setCurrentState(engine.getCurrentState());
  };

  // Capability: renderApplication
  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-4">
      <h1 className="text-4xl font-bold mb-8">Pomodoro Timer</h1>
      <TimerDisplay
        remainingTime={remainingTime}
        currentMode={currentMode}
        currentState={currentState}
      />
      <ControlButtons
        currentState={currentState}
        onStart={handleStart}
        onPause={handlePause}
        onReset={handleReset}
        onSelectMode={handleSelectMode}
      />
    </div>
  );
}